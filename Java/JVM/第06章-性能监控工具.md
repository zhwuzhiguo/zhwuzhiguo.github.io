# 第06章-性能监控工具

## 6.1 Linux下的性能监控工具

### 6.1.1 显示系统整体资源使用情况-top命令

    # top
    top - 14:35:07 up 1 day, 22:35,  2 users,  load average: 0.05, 0.03, 0.00
    Tasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie
    %Cpu(s):  0.5 us,  0.7 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
    MiB Mem :   1713.7 total,    232.2 free,    214.9 used,   1266.6 buff/cache
    MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1326.3 avail Mem
    
        PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
       1028 root      10 -10  165416  21188  16524 S   2.0   1.2  43:38.98 AliYunDun
       1020 root      20   0   43592   6536   5080 S   0.3   0.4   1:24.95 AliYunDunUpdate
          1 root      20   0  172584  10600   7908 S   0.0   0.6   0:02.79 systemd
          2 root      20   0       0      0      0 S   0.0   0.0   0:00.03 kthreadd
          3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp

说明:

1. 系统运行时间和平均负载:

        top - 14:35:07 up 1 day, 22:35,  2 users,  load average: 0.05, 0.03, 0.00
        系统当前时间: 14:35:07
        系统已运行时间: 1 day, 22:35
        系统当前登录用户数: 2
        系统最近5,10,15分钟内的平均负载: 0.05, 0.03, 0.00

2. 任务(进程):

        Tasks: 104 total,   1 running, 103 sleeping,   0 stopped,   0 zombie
        进程总数: 104
        运行进程数量: 1
        睡眠进程数量: 103
        停止进程数量: 0
        僵尸进程数量: 0

3. CPU 状态:

        %Cpu(s):  0.5 us,  0.7 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
        us: user-运行用户进程占用的CPU时间百分比(未调整优先级的用户进程)
        sy: system-运行内核进程占用的CPU时间百分比
        ni: niced-运行用户进程占用的CPU时间百分比(已调整优先级的用户进程)
        id: idle-CPU空闲时间百分比
        wa: IO wait-用于等待IO完成占用的CPU时间百分比
        hi: 处理硬件中断的CPU时间
        si: 处理软件中断的CPU时间
        st: 适用于虚拟机

4. 内存使用:
   
        MiB Mem :   1713.7 total,    232.2 free,    214.9 used,   1266.6 buff/cache
        MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1326.3 avail Mem
        MiB: 兆字节
        Mem: 物理内存使用
        Swap: 交换空间使用
        total: 全部内存
        free: 空闲内存
        used: 使用内存
        buff/cache: 缓冲内存
        avail Mem: 可用内存

4. 列信息: 

        PID: 进程ID
        USER: 进程所有者用户名   
        PR: 进程的调度优先级
            它是进程的实际优先级，从Linux内核来看，是进程的调度优先级。
            对于普通进程，内核优先级是nice值+20。
            因此，nice值为0的进程的内核优先级为20。
            对于实时态运行的进程，该字段的值为RT。

        NI: 进程的nice值(优先级)。越小的值意味着越高的优先级。
            它是对应于用户空间概念的进程的优先级。
            nice值范围是-20到+19，其中-20最高，0默认值，+19最低。
            较低的值意味着较高的优先级。
            nice值和优先级之间的关系是 PR = 20 + NI

        VIRT: 进程使用的虚拟内存
            1. 进程需要的虚拟内存大小，包括进程使用的库、代码、数据等。
            2. 假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量。

        RES: 驻留内存大小
            1. 进程当前使用的内存大小，不包括swap out。
            2. 包含其他进程的共享。
            3. 如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反。
            4. 关于库占用内存的情况，它只统计加载的库文件所占内存大小。

        SHR: SHR是进程使用的共享内存
            1. 除了自身进程的共享内存，也包括其他进程的共享内存。
            2. 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小。
            3. 计算某个进程所占的物理内存大小公式：RES – SHR。
            4. swap out后，它将会降下来。

        S: 进程的状态。它有以下不同的值：
            D - 不可中断的睡眠态
            R – 运行态
            S – 睡眠态
            T – 被跟踪或已停止
            Z – 僵尸态

        %CPU: 自从上一次更新时到现在任务所使用的CPU时间百分比
        %MEM: 进程使用的可用物理内存百分比
        TIME+: 任务启动后到现在所使用的全部CPU时间(精确到百分之一秒)
        COMMAND: 运行进程所使用的命令

5. 交互命令

        h: 显示交互帮助

        回车或者空格: 默认数据3秒刷新，要手动刷新，用户可以输入回车或者空格

        l: 切换平均负载的显示

        t: 切换任务/CPU状态显示

        m: 切换内存信息的显示

        f: 进入字段管理
           上下键选择字段:
               1. 空格切换是否显示
               2. s选择按该字段排序
           右键选中字段:
               1. 上下键移动选中字段显示顺序
           q退出

        R: 切换排序字段正反序

        c: 切换显示完整命令路径

        i: 切换显示空闲任务(自上次更新以来未使用任何CPU的任务)

        V: 显示父子层次结构中的进程

        A: 切换进入交替显示模式
            Def: sorted by %CPU
            Job: sorted by PID
            Mem: sorted by %MEM
            Usr: sorted by User field
            窗口切换: 
            a 移动到下一个窗口
            w 移动到上一个窗口

        Z: 进入设置显示颜色屏幕

        z: 打开或关闭彩色显示

        x: 切换当前排序字段突出显示

        y: 切换正在运行的任务突出显示

        u: 显示特定用户的进程
           系统会提示输入用户名
           空白将为所有用户显示

        n: 设置显示的最大任务数
           系统会提示输入要显示的任务数

        k: 杀进程
           系统会提示输入PID

        1: 切换cpu信息是否分别显示

        H: 切换进程/线程显示模式

6. 命令参数
   
        top -p pid_value
        指定要监视的 PID

        top -H -p pid_value
        查看指定进程的线程信息列表

        printf "%x" 16622
        打印线程ID的16进制表示


### 6.1.2 监控内存和CPU-vmstat命令

    # vmstat
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0      0 244840   3904 1339780    0    0    67   179  380  699  1  1 99  0  0

说明:

    procs: 
    ----------
    r: 等待运行的进程数
       如果长期大于等于逻辑cpu个数则cpu资源可能存在瓶颈。
    b: 处在非中断睡眠状态的进程数(被阻塞的进程数)
       主要是指被资源阻塞的进程数(比如IO资源、页面调度等)。       

    memory:  
    ----------
    swpd: 已使用的虚拟内存大小(KB)
    free: 空闲的物理内存的大小(KB)
    buff:  用来做buffer(缓存，主要用于块设备缓存)的内存数(KB)
    cache: 用来做cache (缓存，主要用于文件缓存)的内存数(KB)

    swap: 
    ----------
    si: 每秒从交换区读到内存的大小(由磁盘调入内存)
    so: 每秒从内存写到交换区的大小(由内存调入磁盘)
    注意: 
    内存够用的时候这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。

    io:  
    ----------
    bi: 每秒从块设备读取的块数(块/秒)
    bo: 每秒写入到块设备的块数(块/秒)

    system:  
    ----------
    in: 每秒中断数(包括时钟中断)
    cs: 每秒上下文切换数
    注意: 
    这2个值越大，会看到由内核消耗的CPU时间会越大。

    cpu:  
    ----------
    us: 用户进程CPU时间(单位为百分比)
    sy: 内核进程CPU时间(单位为百分比)
    id: 空闲的CPU时间(单位为百分比)
    wa: 等待IO的CPU时间(单位为百分比)
    st: 适用于虚拟机
    注意: 
    即使us+sy接近100%，也要看r(等待运行的进程数)，Linux会尽量的让CPU忙碌起来。


示例:

1. 查看帮助

        # vmstat -h
        
        Usage:
         vmstat [options] [delay [count]]
        
        Options:
         -a, --active           active/inactive memory
         -f, --forks            number of forks since boot
         -m, --slabs            slabinfo
         -n, --one-header       do not redisplay header
         -s, --stats            event counter statistics
         -d, --disk             disk statistics
         -D, --disk-sum         summarize disk statistics
         -p, --partition <dev>  partition specific statistics
         -S, --unit <char>      define display unit
         -w, --wide             wide output
         -t, --timestamp        show timestamp
        
         -h, --help     display this help and exit
         -V, --version  output version information and exit
        
        For more details see vmstat(8).

2. 每几秒输出一条结果

        # vmstat 2
        procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
         r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
         0  0      0 243676   3904 1340844    0    0    21    57  354  676  0  1 99  0  0
         0  0      0 243472   3904 1340844    0    0     0     0  656 1297  0  1 99  0  0
         0  0      0 243472   3904 1340844    0    0     0     0  671 1326  0  1 99  0  0
         0  0      0 243504   3904 1340844    0    0     0     0  757 1403  0  1 99  0  0

3. 宽格式显示

        # vmstat -w 2
        procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
         r  b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
         2  0            0       240848         3904      1340848    0    0    21    57  354  676   0   1  99   0   0
         1  0            0       240752         3904      1340848    0    0     0     0  733 1372   0   1  99   0   0
         0  0            0       240752         3904      1340848    0    0     0     4  701 1333   0   1  99   0   0
         0  0            0       240752         3904      1340848    0    0     0     0  692 1348   1   0  99   0   0

4. 指定显示单位

        # vmstat -w -S k 2
        procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
         r  b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
         0  0            0       247427         3997      1373028    0    0    21    56  353  676   0   1  99   0   0
        
        # vmstat -w -S m 2
        procs -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
         r  b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
         0  0            0          247            3         1373    0    0    21    56  353  676   0   1  99   0   0
         0  0            0          247            3         1373    0    0     0     0  664 1305   1   1  99   0   0


### 6.1.3 监控I/O-iostat命令

    # iostat
    Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月18日 	    _x86_64_	(2 CPU)
    
    avg-cpu:  %user   %nice %system %iowait  %steal   %idle
               0.41    0.00    0.56    0.04    0.00   98.99
    
    Device             tps    kB_read/s    kB_wrtn/s    kB_read        kB_wrtn
    vda               1.48        36.23        97.23     385177        1033735

说明:

    avg-cpu:
    ----------
    %user: CPU处在用户模式下的时间百分比
    %nice: CPU处在带NICE值的用户模式下的时间百分比
    %system: CPU处在系统模式下的时间百分比
    %iowait: CPU等待输入输出完成时间的百分比
    %steal: 管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比
    %idle: CPU空闲时间百分比

    Device:  
    ----------
    tps: 该设备每秒的传输次数
    kB_read/s: 每秒从设备读取的数据量
    kB_wrtn/s: 每秒向设备写入的数据量
    kB_read: 读取的总数据量
    kB_wrtn: 写入的总数据量

示例:

1. 查看帮助

        # iostat -help
        用法: iostat [ 选项 ] [ <时间间隔> [ <次数> ] ]
        Options are:
        [ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -s ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ]
        [ -j { ID | LABEL | PATH | UUID | ... } ] [ --human ] [ -o JSON ]
        [ [ -H ] -g <group_name> ] [ -p [ <device> [,...] | ALL ] ]
        [ <device> [...] | ALL ]

        -c：仅显示CPU使用情况

        -d：仅显示设备利用率

        -k：显示状态以千字节每秒为单位

        -m：显示状态以兆字节每秒为单位

        -p：仅显示块设备和所有被使用的其他分区的状态

        -t：显示每个报告产生时的时间

        -V：显示版号并退出

        -x：显示扩展状态

2. 每几秒输出一条结果

        # iostat 2
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月18日 	        _x86_64_	(2 CPU)
        
        avg-cpu:  %user   %nice %system %iowait  %steal   %idle
                   0.40    0.00    0.56    0.03    0.00   99.00
        
        Device             tps    kB_read/s    kB_wrtn/s    kB_read            kB_wrtn
        vda               1.36        32.97        88.66     385177            1035705
        
        avg-cpu:  %user   %nice %system %iowait  %steal   %idle
                   0.25    0.00    0.50    0.00    0.00   99.25
        
        Device             tps    kB_read/s    kB_wrtn/s    kB_read            kB_wrtn
        vda               0.00         0.00         0.00                  0          0


### 6.1.4 多功能诊断器-pidstat工具

    # pidstat -help
    Usage: pidstat [ options ] [ <interval> [ <count> ] ] [ -e <program> <args> ]
    Options are:
    [ -d ] [ -H ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ <username> ] ]
    [ -u ] [ -V ] [ -v ] [ -w ] [ -C <command> ] [ -G <process_name> ] [ --human ]
    [ -p { <pid> [,...] | SELF | ALL } ] [ -T { TASK | CHILD | ALL } ]

可选项:

    -u 显示各个进程的CPU使用统计(默认的参数)
    -r 显示各个进程的内存使用统计
    -d 显示各个进程的IO使用情况
    -w 显示各个进程的上下文切换情况
    -p 指定进程号
    -t 显示选择任务的线程的统计信息外的额外信息
    -V：版本号 
    -l：显示命令名和所有参数

示例:

1. 显示各个进程的CPU使用统计

        # pidstat -u
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        16时17分44秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
        16时17分44秒     0         1    0.00    0.00    0.00    0.00    0.00     0  systemd
        16时17分44秒     0         2    0.00    0.00    0.00    0.00    0.00     1  kthreadd
        ...
        16时17分44秒     0      7575    0.00    0.00    0.00    0.00    0.00     0  bash
        16时17分44秒     0      7651    0.00    0.00    0.00    0.00    0.00     0  java

        说明:
        UID: 用户ID
        PID: 进程ID
        %usr: 进程在用户空间占用CPU的百分比
        %system: 进程在内核空间占用CPU的百分比
        %guest: 进程花费在虚拟机上的CPU的百分比(运行在虚拟处理器)
        %wait: 进程在等待运行时花费的CPU的百分比
        %CPU: 进程总的CPU使用率
        CPU: 正在运行这个进程的处理器编号
        Command: 这个进程的命令名称

        注意: 
        # pidstat -u 1
        加上时间间隔参数才是实时数据，否则为系统启动开始的各项统计信息。


2. 显示各个进程的内存使用统计

        # pidstat -r
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        16时21分36秒   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
        16时21分36秒     0         1      0.39      0.00  172572   10472   0.60  systemd
        ...
        16时21分36秒     0      7651      0.01      0.00 2672320   29008   1.65  java

        说明:
        minflt/s: 从内存中加载数据时每秒出现的次要错误的数目，这些不要求从磁盘载入内存页面
        majflt/s: 从内存中加载数据时每秒出现的主要错误的数目，这些要求从磁盘载入内存页面，一般在内存使用紧张时产生
        VSZ: 占用的虚拟内存大小，包括进入交换分区的内存
        RSS: 占用的物理内存大小，不包括进入交换分区的内存
        %MEM: 进程使用的物理内存百分比

3. 显示各个进程的IO使用情况

        # pidstat -d
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        16时22分16秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
        16时22分16秒     0         1      1.22      3.76      0.16      16  systemd
        ...
        16时22分16秒     0      7651      0.00      0.00      0.00       0  java

        说明:
        kB_rd/s: 进程每秒从磁盘读取的数据量(以kB为单位)
        kB_wr/s: 进程每秒向磁盘写入的数据量(以kB为单位)
        kB_ccwr/s: 进程写入磁盘被取消的速率(以kB为单位)
        iodelay: 进程的I/O阻塞延迟，以时钟周期为单位，包括等待同步块I/O和换入块I/O结束的时间

4. 显示各个进程的上下文切换情况

        [root@centos app]# pidstat -w
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        16时22分43秒   UID       PID   cswch/s nvcswch/s  Command
        16时22分43秒     0         1      0.04      0.00  systemd
        16时22分43秒     0         2      0.01      0.00  kthreadd
        ...
        16时22分43秒     0      7651      0.00      0.00  java

        说明:
        cswch/s: 表示每秒自愿上下文切换的次数(进程无法获得所需的资源导致的上下文切换)
        nvcswch/s: 表示每秒非自愿上下文切换的次数(进程由于cpu分配的时间片耗尽被系统强制调度导致的上下文切换)

5. 显示选择任务的线程的统计信息外的额外信息

        // 查看Java进程ID
        # jps
        7651 HoldCPUExample
        7769 Jps

        // 查看Java进程CPU占用
        // CPU占用高
        # pidstat -u -p 7651 1
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        17时03分31秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
        17时03分32秒     0      7651  100.00    0.00    0.00    0.00  100.00     0  java
        17时03分33秒     0      7651   99.00    0.00    0.00    0.00   99.00     0  java
        17时03分34秒     0      7651  100.00    0.00    0.00    0.00  100.00     0  java
        17时03分35秒     0      7651  100.00    0.00    0.00    0.00  100.00     0  java

        // 查看Java进程内线程的CPU占用
        // 线程7661的CPU占用高
        # pidstat -u -t -p 7651 1
        Linux 4.18.0-348.2.1.el8_5.x86_64 (centos) 	2022年02月21日 	_x86_64_	(2 CPU)

        17时05分54秒   UID      TGID       TID    %usr %system  %guest   %wait    %CPU   CPU  Command
        17时05分55秒     0      7651         -  100.00    0.00    0.00    0.00  100.00     0  java
        17时05分55秒     0         -      7651    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7652    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7653    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7654    0.00    0.00    0.00    0.00    0.00     1  |__java
        17时05分55秒     0         -      7655    0.00    0.00    0.00    0.00    0.00     1  |__java
        17时05分55秒     0         -      7656    0.00    0.00    0.00    0.00    0.00     1  |__java
        17时05分55秒     0         -      7657    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7658    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7659    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7660    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7661  100.00    0.00    0.00    0.00  100.00     1  |__java
        17时05分55秒     0         -      7662    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7663    0.00    0.00    0.00    0.00    0.00     0  |__java
        17时05分55秒     0         -      7664    0.00    0.00    0.00    0.00    0.00     0  |__java

        // 获取Java进程的线程栈数据
        // 找到线程7661(nid=0x1ded)的线程调用栈分析执行代码
        # jstack -l 7651 > ./7651.txt

        ...
        43 "Thread-HoldCPUTask" #8 prio=5 os_prio=0 tid=0x00007f34440df000 nid=0x1ded runnable [0x00007f3432dc3000]
        44    java.lang.Thread.State: RUNNABLE
        45         at HoldCPUExample$HoldCPUTask.run(HoldCPUExample.java:8)
        46         at java.lang.Thread.run(Thread.java:748)
        ...

## 6.2 Windows下的性能监控工具
略..

## 6.3 JDK性能监控工具

### 6.3.1 查看Java进程-jps命令

查看Java进程。

        # jps
        10241 Example
        10264 Jps

        // 只显示进程ID
        # jps -q
        10241
        10274

        // 显示主类的完整包名
        # jps -l
        10241 Example
        10284 sun.tools.jps.Jps

        // 显示程序参数
        # jps -m
        10241 Example aaa bbb
        10294 Jps -m

        // 显示虚拟机参数
        # jps -v
        10304 Jps -Denv.class.path=.:/usr/local/java/jdk1.8.0_201/lib:/usr/local/java/jdk1.8.0_201/jre/lib -Dapplication.home=/usr/local/java/jdk1.8.0_201 -Xms8m
        10241 Example -Xmx320m

        # jps -lvm
        10241 Example aaa bbb -Xmx320m
        10314 sun.tools.jps.Jps -lvm -Denv.class.path=.:/usr/local/java/jdk1.8.0_201/lib:/usr/local/java/jdk1.8.0_201/jre/lib -Dapplication.home=/usr/local/java/jdk1.8.0_201 -Xms8m


### 6.3.2 查看虚拟机运行时信息-jstat命令

监控Java进程。

        可以做如下监控:
        1 类的加载及卸载情况。
        2 查看新生代、老生代及持久代的容量及使用情况。
        3 查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间。
        4 查看新生代中Eden区及Survior区中容量及分配情况等。

        jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
        
        说明:
        -t
        输出程序运行时间    

        -h
        指定每输出多少行数据后输出一个表头信息

        vmid
        Java进程ID

        interval
        输出统计数据的周期(默认毫秒或手动指定s|ms)

        count
        指定一共输出多少次数据

选项:

        -class
        显示类加载信息
        Loaded      已加载类的数量
        Bytes       已加载类的大小(KB)
        Unloaded    已卸载类的数量
        Bytes       已卸载类的大小(KB)
        Time        类加载及卸载耗时
        
        # jstat -class -h3 11166 1s 3
        Loaded  Bytes  Unloaded  Bytes     Time
           385   803.6        0     0.0       0.04
           385   803.6        0     0.0       0.04
           385   803.6        0     0.0       0.04
        
        -compiler
        显示即时编译器编译信息
        Compiled        编译任务执行的次数
        Failed          编译任务执行失败的次数
        Invalid         编译不可用的次数
        Time            执行编译花费的时间
        FailedType      最后一次编译失败的编译类型
        FailedMethod    最后一次编译失败的类名及方法名
        
        # jstat -compiler -h3 11166 1s 3
        Compiled Failed Invalid   Time   FailedType FailedMethod
              33      0       0     0.01          0
              33      0       0     0.01          0
              33      0       0     0.01          0
        
        -gc
        显示GC相关堆信息
        S0C     新生代中S0当前容量大小(KB)
        S1C     新生代中S1当前容量大小(KB)
        S0U     新生代中S0容量使用大小(KB)
        S1U     新生代中S1容量使用大小(KB)
        EC      Eden当前容量大小(KB)
        EU      Eden容量使用大小(KB)
        OC      Old当前容量大小(KB)
        OU      Old使用容量大小(KB)
        MC      元空间(Meta)当前容量大小(KB)
        MU      元空间(Meta)使用容量大小(KB)
        CCSC    压缩类空间大小(KB)
        CCSU    压缩类空间使用大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        YGCT    从应用程序启动到采样时Young GC所用的时间(秒)
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        
        # jstat -gc -h3 11166 1s 3
         S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
        9920.0 9920.0  0.0   9220.2 79424.0  40462.1   198420.0   189711.7  4864.0 2484.8 512.0  264.6      15    0.095   4      0.036    0.131
        9920.0 9920.0  0.0   9220.2 79424.0  42510.2   198420.0   189711.7  4864.0 2484.8 512.0  264.6      15    0.095   4      0.036    0.131
        9920.0 9920.0  0.0   9220.2 79424.0  44558.2   198420.0   189711.7  4864.0 2484.8 512.0  264.6      15    0.095   4      0.036    0.131
        
        -gccapacity
        显示各个代的容量和使用情况
        NGCMN   新生代最小容量大小(KB)
        NGCMX	新生代最大容量大小(KB)
        NGC     当前新生代容量大小(KB)
        S0C     当前新生代中S0容量大小(KB)
        S1C     当前新生代中S1容量大小(KB)
        EC      Eden当前容量的大小(KB)
        OGCMN   Old最小容量大小(KB)
        OGCMX   Old最大容量大小(KB)
        OGC     当前Old的容量大小(KB)
        OC      当前Old的容量大小(KB)
        MCMN    Meta space最小容量大小(KB)
        MCMX    Meta space最大容量大小(KB)
        MC      当前Meta space容量大小(KB)
        CCSMN   最小压缩类空间大小(KB)
        CCSMX   最大压缩类空间大小(KB)
        CCSC    当前压缩类空间大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        FGC     从应用程序启动到采样时发生Full GC的次数
        
        # jstat -gccapacity -h3 11166 1s 3
         NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN            CCSMX     CCSC    YGC    FGC
          9536.0 349504.0  99264.0 9920.0 9920.0  79424.0    19136.0   699072.0   198420.0   198420.0      0.0 1056768.0   4864.0      0.0 1048576.        0    512.0     15     4
          9536.0 349504.0  99264.0 9920.0 9920.0  79424.0    19136.0   699072.0   198420.0   198420.0      0.0 1056768.0   4864.0      0.0 1048576.        0    512.0     15     4
          9536.0 349504.0  99264.0 9920.0 9920.0  79424.0    19136.0   699072.0   198420.0   198420.0      0.0 1056768.0   4864.0      0.0 1048576.        0    512.0     15     4
        
        -gccause
        显示垃圾收集相关信息(和-gcutil一样)
        同时显示最后一次和当前正在发生的垃圾收集的原因
        S0      S0区已使用空间的百分比
        S1      S1区已使用空间的百分比
        E       Eden区已使用空间的百分比
        O       Old区已使用空间的百分比
        M       Meta space区已使用空间的百分比
        CCS     压缩类空间已使用空间的百分比
        YGC     从应用程序启动到采样时发生Young GC的次数
        YGCT    从应用程序启动到采样时Young GC所用的时间(秒)
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        LGCC    最后一次垃圾收集的原因
        GCC     当前垃圾收集的原因
        
        # jstat -gccause -h3 11166 1s 3
          S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC
          0.00   0.00   9.35  60.00  51.08  51.68     16    0.120     5    0.039    0.159 Allocation Failure   No GC
          0.00   0.00  10.69  60.00  51.08  51.68     16    0.120     5    0.039    0.159 Allocation Failure   No GC
          0.00   0.00  12.03  60.00  51.08  51.68     16    0.120     5    0.039    0.159 Allocation Failure   No GC
        
        -gcmetacapacity
        显示元空间的存储容量情况(JDK8)
        MCMN    Meta space最小容量大小(KB)
        MCMX    Meta space最大容量大小(KB)
        MC      当前Meta space容量大小(KB)
        CCSMN   最小压缩类空间大小(KB)
        CCSMX   最大压缩类空间大小(KB)
        CCSC    当前压缩类空间大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(单位秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        
        # jstat -gcmetacapacity -h3 11166 1s 3
           MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT
               0.0  1056768.0     4864.0        0.0  1048576.0      512.0    16     5    0.039    0.159
               0.0  1056768.0     4864.0        0.0  1048576.0      512.0    16     5    0.039    0.159
               0.0  1056768.0     4864.0        0.0  1048576.0      512.0    16     5    0.039    0.159
        
        -gcnew
        显示新生代信息
        S0C     新生代中S0容量大小(KB)
        S1C     新生代中S1容量大小(KB)
        S0U     新生代中S0容量使用大小(KB)
        S1U     新生代中S1容量使用大小(KB)
        TT      晋升老年代的年龄(Tenuring threshold)
        MTT     晋升老年代的最大年龄
        DSS     所需的Survivor区大小(KB)
        EC      新生代中Eden容量大小(KB)
        EU      新生代中Eden容量使用大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        YGCT    从应用程序启动到采样时Young GC所用的时间(秒)
        
        # jstat -gcnew -h3 11166 1s 3
         S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT
        19008.0 19008.0    0.0    0.0  1  15 4960.0 152576.0  73655.2     16    0.120
        19008.0 19008.0    0.0    0.0  1  15 4960.0 152576.0  75703.3     16    0.120
        19008.0 19008.0    0.0    0.0  1  15 4960.0 152576.0  77751.3     16    0.120
        
        -gcnewcapacity
        显示新生代大小和使用情况
        NGCMN   新生代的最小容量大小
        NGCMX   新生代的最大容量大小
        NGC     当前新生代容量大小
        S0CMX   新生代中SO最大容量大小
        S0C     当前新生代中SO容量大小
        S1CMX   新生代中S1最大容量大小
        S1C     当前新生代中S1的容量大小
        ECMX    新生代中Eden最大容量大小
        EC      当前新生代中Eden容量大小
        YGC     从应用程序启动到采样时发生Young GC的次数
        FGC     从应用程序启动到采样时发生Full GC的次数
        
        # jstat -gcnewcapacity -h3 11166 1s 3
          NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC
            9536.0   349504.0   190592.0  34944.0  19008.0  34944.0  19008.0   279616.0   152576.0    16     5
            9536.0   349504.0   190592.0  34944.0  19008.0  34944.0  19008.0   279616.0   152576.0    16     5
            9536.0   349504.0   190592.0  34944.0  19008.0  34944.0  19008.0   279616.0   152576.0    16     5
        
        -gcold
        显示老年代和永久代信息
        MC      Meta space当前容量大小(KB)
        MU      Meta space使用容量大小(KB)
        CCSC    压缩类空间大小(KB)
        CCSU    压缩类空间使用大小(KB)
        OC      Old space当前容量大小(KB)
        OU      Old space使用容量大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        
        # jstat -gcold -h3 11166 1s 3
           MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT
          4864.0   2484.8    512.0    264.6    381052.0    228629.2     16     5    0.039    0.159
          4864.0   2484.8    512.0    264.6    381052.0    228629.2     16     5    0.039    0.159
          4864.0   2484.8    512.0    264.6    381052.0    228629.2     16     5    0.039    0.159
        
        -gcoldcapacity
        显示老年代大小
        OGCMN   Old space最小容量大小(KB)
        OGCMX   Old space最大容量大小(KB)
        OGC     当前Old space容量大小(KB)
        OC      当前Old space容量大小(KB)
        YGC     从应用程序启动到采样时发生Young GC的次数
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        
        # jstat -gcoldcapacity -h3 11166 1s 3
           OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT
            19136.0    699072.0    381052.0    381052.0    17     5    0.039    0.214
            19136.0    699072.0    381052.0    381052.0    17     5    0.039    0.214
            19136.0    699072.0    381052.0    381052.0    17     5    0.039    0.214
        
        -gcutil
        显示垃圾收集相关信息
        S0      S0区已使用空间的百分比
        S1      S1区已使用空间的百分比
        E       Eden区已使用空间的百分比
        O       Old区已使用空间的百分比
        M       Meta space区已使用空间的百分比
        CCS     压缩类空间已使用空间的百分比
        YGC     从应用程序启动到采样时发生Young GC的次数
        YGCT    从应用程序启动到采样时Young GC所用的时间(秒)
        FGC     从应用程序启动到采样时发生Full GC的次数
        FGCT    从应用程序启动到采样时Full GC所用的时间(秒)
        GCT     从应用程序启动到采样时用于垃圾回收的总时间(YGCT+FGCT)(秒)
        
        # jstat -gcutil -h3 11166 1s 3
          S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
          0.00  97.02  20.05  76.66  51.54  51.68     17    0.174     5    0.039    0.214
          0.00  97.02  21.39  76.66  51.54  51.68     17    0.174     5    0.039    0.214
          0.00  97.02  22.73  76.66  51.54  51.68     17    0.174     5    0.039    0.214
        
        -printcompilation
        显示即使编译的方法信息
        Compiled    编译任务执行的次数
        Size        方法的字节码所占的字节数
        Type        编译类型
        Method      指定确定被编译方法的类名及方法名
        
        # jstat -printcompilation -h3 11166 1s 3
        Compiled  Size  Type Method
              73    161    1 java/lang/AbstractStringBuilder append
              75    161    1 java/lang/AbstractStringBuilder append
              75    161    1 java/lang/AbstractStringBuilder append
        
总结3个常用选项：

1. -gcutil 显示各区域内存信息:
   - 使用比例
   - 垃圾回收情况

         # jstat -gcutil -h30 12004 1s
           S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
           0.00  94.71  39.00  49.66  50.83  51.68      3    0.032     0    0.000    0.032
           0.00  94.71  41.49  49.66  50.83  51.68      3    0.032     0    0.000    0.032
           0.00  94.71  43.97  49.66  50.83  51.68      3    0.032     0    0.000    0.032

2. -gc 显示各区域内存信息:
   - 总量
   - 使用量
   - 垃圾回收情况

         # jstat -gc -h30 12004 1s
          S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU             CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
         13312.0 13312.0  0.0   12608.2 82432.0  36245.9   218624.0   108569.7  4864.0 2472.4 512.         0  264.6       3    0.032   0      0.000    0.032
         13312.0 13312.0  0.0   12608.2 82432.0  38293.9   218624.0   108569.7  4864.0 2472.4 512.         0  264.6       3    0.032   0      0.000    0.032
         13312.0 13312.0  0.0   12608.2 82432.0  40341.9   218624.0   108569.7  4864.0 2472.4 512.         0  264.6       3    0.032   0      0.000    0.032

3. -gccapacity 显示各区域内存信息:
   - 最大最小值
   - 当前总量
   - 垃圾回收情况

         # jstat -gccapacity -h30 12004 1s
          NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
         109056.0 109056.0 109056.0 13312.0 13312.0  82432.0   218624.0   218624.0   218624.0   218624.0      0.0 1056768.0   4864.0      0.0 1048576.0    512.0      3     0
         109056.0 109056.0 109056.0 13312.0 13312.0  82432.0   218624.0   218624.0   218624.0   218624.0      0.0 1056768.0   4864.0      0.0 1048576.0    512.0      3     0
         109056.0 109056.0 109056.0 13312.0 13312.0  82432.0   218624.0   218624.0   218624.0   218624.0      0.0 1056768.0   4864.0      0.0 1048576.0    512.0      3     0


### 6.3.3 查看虚拟机参数-jinfo命令

查看Java进程的扩展参数，也可以修改部分参数。

    jinfo [option] <pid>
    
    option:
    -flag <name>         打印指定Java虚拟机参数
    -flag [+|-]<name>    设置指定Java虚拟机参数的布尔值
    -flag <name>=<value> 设置指定Java虚拟机参数的值
    -flags               打印Java虚拟机参数
    -sysprops            打印Java系统属性
    <no option>          同时打印Java虚拟机参数和Java系统属性

示例:

    # jinfo -flag PrintGCDetails 12735
    -XX:+PrintGCDetails
    
    # jinfo -flag -PrintGCDetails 12735
    
    # jinfo -flag PrintGCDetails 12735
    -XX:-PrintGCDetails
    
    # jinfo -flag +PrintGCDetails 12735
    
    # jinfo -flag PrintGCDetails 12735
    -XX:+PrintGCDetails
    
    
    # jinfo -flag MaxTenuringThreshold=10 12874
    Exception in thread "main" com.sun.tools.attach.AttachOperationFailedException: flag 'MaxTenuringThreshold' cannot be changed
    
    	at sun.tools.attach.LinuxVirtualMachine.execute(LinuxVirtualMachine.java:229)
    	at sun.tools.attach.HotSpotVirtualMachine.executeCommand(HotSpotVirtualMachine.java:261)
    	at sun.tools.attach.HotSpotVirtualMachine.setFlag(HotSpotVirtualMachine.java:234)
    	at sun.tools.jinfo.JInfo.flag(JInfo.java:134)
    	at sun.tools.jinfo.JInfo.main(JInfo.java:81)
    
    # jinfo -flags 12874
    Attaching to process ID 12874, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.201-b09
    Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=335544320 -XX:MaxHeapSize=335544320 -XX:MaxNewSize=111673344 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111673344     -XX:OldSize=223870976 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelOldGC
    Command line:  -Xms320m -Xmx320m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC
    
    # jinfo -sysprops 12874
    Attaching to process ID 12874, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.201-b09
    java.runtime.name = Java(TM) SE Runtime Environment
    java.vm.version = 25.201-b09
    sun.boot.library.path = /usr/local/java/jdk1.8.0_201/jre/lib/amd64
    java.vendor.url = http://java.oracle.com/
    java.vm.vendor = Oracle Corporation
    ...
    
    # jinfo 12874
    Attaching to process ID 12874, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.201-b09
    Java System Properties:
    
    java.runtime.name = Java(TM) SE Runtime Environment
    java.vm.version = 25.201-b09
    sun.boot.library.path = /usr/local/java/jdk1.8.0_201/jre/lib/amd64
    java.vendor.url = http://java.oracle.com/
    java.vm.vendor = Oracle Corporation
    ...
    
    VM Flags:
    Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=335544320 -XX:MaxHeapSize=335544320 -XX:MaxNewSize=111673344 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111673344     -XX:OldSize=223870976 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelOldGC
    Command line:  -Xms320m -Xmx320m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC


### 6.3.4 导出堆到文件-jmap命令

多功能命令。

    jmap [option] <pid>

1. 打印堆信息

        # jmap -heap 15188
        Attaching to process ID 15188, please wait...
        Debugger attached successfully.
        Server compiler detected.
        JVM version is 25.201-b09
        
        using thread-local object allocation.
        Parallel GC with 2 thread(s)
        
        Heap Configuration:
           MinHeapFreeRatio         = 0
           MaxHeapFreeRatio         = 100
           MaxHeapSize              = 335544320 (320.0MB)
           NewSize                  = 111673344 (106.5MB)
           MaxNewSize               = 111673344 (106.5MB)
           OldSize                  = 223870976 (213.5MB)
           NewRatio                 = 2
           SurvivorRatio            = 8
           MetaspaceSize            = 21807104 (20.796875MB)
           CompressedClassSpaceSize = 1073741824 (1024.0MB)
           MaxMetaspaceSize         = 17592186044415 MB
           G1HeapRegionSize         = 0 (0.0MB)
        
        Heap Usage:
        PS Young Generation
        Eden Space:
           capacity = 84410368 (80.5MB)
           used     = 7950400 (7.58209228515625MB)
           free     = 76459968 (72.91790771484375MB)
           9.418748180318323% used
        From Space:
           capacity = 13631488 (13.0MB)
           used     = 12894416 (12.297073364257812MB)
           free     = 737072 (0.7029266357421875MB)
           94.59287203275241% used
        To Space:
           capacity = 13631488 (13.0MB)
           used     = 0 (0.0MB)
           free     = 13631488 (13.0MB)
           0.0% used
        PS Old Generation
           capacity = 223870976 (213.5MB)
           used     = 70272048 (67.01664733886719MB)
           free     = 153598928 (146.4833526611328MB)
           31.389530369492828% used
        
        692 interned Strings occupying 46048 bytes.

2. 打印对象统计信息

        # jmap -histo 15188
        
         num     #instances         #bytes  class name
        ----------------------------------------------
           1:           146      144730680  [B
           2:            98        2349328  [I
           3:          1173          90600  [C
           4:           450          51392  java.lang.Class
           5:          1133          27192  java.lang.String
           6:           501          25336  [Ljava.lang.Object;
           7:            75           5400  java.lang.reflect.Field
           8:           256           4096  java.lang.Integer
           9:            89           3560  java.lang.ref.SoftReference
          10:           109           3488  java.util.Hashtable$Entry
          11:           138           3312  Example$User
         ...
         173:             1             16  sun.misc.Unsafe
         174:             1             16  sun.net.www.protocol.file.Handler
         175:             1             16  sun.reflect.ReflectionFactory
        Total          5043      147332224

3. 打印对象统计信息(只包含存活对象)

        # jmap -histo:live 15188
        
         num     #instances         #bytes  class name
        ----------------------------------------------
           1:           126      123758840  [B
           2:          1094          88080  [C
           3:           450          51392  java.lang.Class
           4:          1083          25992  java.lang.String
           5:           501          25552  [Ljava.lang.Object;
           6:            75           5400  java.lang.reflect.Field
           7:           256           4096  java.lang.Integer
           8:            89           3560  java.lang.ref.SoftReference
           9:           109           3488  java.util.Hashtable$Entry
          10:            85           2936  [I
          11:           118           2832  Example$User
         ...
         172:             1             16  sun.misc.Unsafe
         173:             1             16  sun.net.www.protocol.file.Handler
         174:             1             16  sun.reflect.ReflectionFactory
        Total          4772      124006432

4. 打印类加载器信息

        # jmap -clstats 15188
        Attaching to process ID 15188, please wait...
        Debugger attached successfully.
        Server compiler detected.
        JVM version is 25.201-b09
        finding class loader instances ..done.
        computing per loader stat ..done.
        please wait.. computing liveness..................................................................done.
        class_loader	classes	bytes	parent_loader	alive?	type
        
        <bootstrap>	383	747388	  null  	live	<internal>
        0x00000000f2a01d68	2	1870	0x00000000f2a01dc8	live	sun/misc/Launcher$AppClassLoader@0x000000010000f8d8
        0x00000000f2a01dc8	0	0	  null  	live	sun/misc/Launcher$ExtClassLoader@0x000000010000fc80
        
        total = 3	385	749258	    N/A    	alive=3, dead=0	    N/A

5. 打印finalizer队列中的对象信息

        # jmap -finalizerinfo 15188
        Attaching to process ID 15188, please wait...
        Debugger attached successfully.
        Server compiler detected.
        JVM version is 25.201-b09
        Number of objects pending for finalization: 0

6. 导出全部对象堆快照

        # jmap -dump:format=b,file=aaa.bin 15323
        Dumping heap to /root/aaa.bin ...
        Heap dump file created

7. 导出存活对象堆快照

        # jmap -dump:live,format=b,file=aaa-live.bin 15323
        Dumping heap to /root/aaa-live.bin ...
        Heap dump file created

8. 当程序无响应时使用-F选项(支持-dump和-histo)  
   会导致运行的程序暂停

        # jmap -F -dump:format=b,file=aaa-f.bin 15323
        Attaching to process ID 15323, please wait...
        Debugger attached successfully.
        Server compiler detected.
        JVM version is 25.201-b09
        Dumping heap to aaa-f.bin ...
        Heap dump file created


### 6.3.5 JDK自带的堆分析工具-jhat命令

对堆快照文件进行分析，它启动一个HTTP服务，可以通过浏览器查看堆数据。

    # jhat -port 8080 heap.bin
    Reading from heap.bin...
    Dump file created Wed Feb 23 13:52:14 CST 2022
    Snapshot read, resolving...
    Resolving 5208 objects...
    Chasing references, expect 1 dots.
    Eliminating duplicate references.
    Snapshot resolved.
    Started HTTP server on port 8080
    Server is ready.

### 6.3.6 查看线程堆栈-jstack命令

导出Java程序的线程堆栈。

    jstack [option] <pid>

    option:

    -l
    包含锁信息

    -F
    程序无响应时使用

死锁示例:

    # jstack -l 16474
    2022-02-23 16:23:15
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.201-b09 mixed mode):
    
    // JVM 接收外部的命令进行执行并把结果返回给发送者(如jmap,jstack等)
    "Attach Listener" #11 daemon prio=9 os_prio=0 tid=0x00007f7ba0001000 nid=0x4094 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    // JVM 等待其它线程退出时通知它卸载JVM
    "DestroyJavaVM" #10 prio=5 os_prio=0 tid=0x00007f7bc800a800 nid=0x405b waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    "TaskB" #9 prio=5 os_prio=0 tid=0x00007f7bc80d8800 nid=0x4065 waiting for monitor entry [0x00007f7bb6036000]
       java.lang.Thread.State: BLOCKED (on object monitor)
    	at LockExample$TaskB.run(LockExample.java:43)
    	- waiting to lock <0x00000000e525c690> (a java.lang.Object)
    	- locked <0x00000000e525c6a0> (a java.lang.Object)
    	at java.lang.Thread.run(Thread.java:748)
    
       Locked ownable synchronizers:
    	- None
    
    "TaskA" #8 prio=5 os_prio=0 tid=0x00007f7bc80d6800 nid=0x4064 waiting for monitor entry [0x00007f7bb6137000]
       java.lang.Thread.State: BLOCKED (on object monitor)
    	at LockExample$TaskA.run(LockExample.java:19)
    	- waiting to lock <0x00000000e525c6a0> (a java.lang.Object)
    	- locked <0x00000000e525c690> (a java.lang.Object)
    	at java.lang.Thread.run(Thread.java:748)
    
       Locked ownable synchronizers:
    	- None
    
    "Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007f7bc80b8800 nid=0x4062 runnable [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    // JVM 编译线程
    "C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f7bc80b5800 nid=0x4061 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    // JVM 编译线程
    "C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f7bc80b3800 nid=0x4060 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    // Attach Listener线程接收外部jvm命令后
    // 会交给Signal Dispatcher线程去进行分发到各个不同的模块处理命令并且返回处理结果
    "Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007f7bc80b2000 nid=0x405f runnable [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
       Locked ownable synchronizers:
    	- None
    
    // 用于在垃圾收集前调用对象的finalize()方法
    "Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f7bc807b000 nid=0x405e in Object.wait() [0x00007f7bb6a3d000]
       java.lang.Thread.State: WAITING (on object monitor)
    	at java.lang.Object.wait(Native Method)
    	- waiting on <0x00000000e5208ed0> (a java.lang.ref.ReferenceQueue$Lock)
    	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
    	- locked <0x00000000e5208ed0> (a java.lang.ref.ReferenceQueue$Lock)
    	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
    	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)
    
       Locked ownable synchronizers:
    	- None
    
    // 其优先级最高为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题
    "Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f7bc8078800 nid=0x405d in Object.wait() [0x00007f7bb6b3e000]
       java.lang.Thread.State: WAITING (on object monitor)
    	at java.lang.Object.wait(Native Method)
    	- waiting on <0x00000000e5206bf8> (a java.lang.ref.Reference$Lock)
    	at java.lang.Object.wait(Object.java:502)
    	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
    	- locked <0x00000000e5206bf8> (a java.lang.ref.Reference$Lock)
    	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
    
       Locked ownable synchronizers:
    	- None
    
    // JVM自身启动的一个线程
    // 它主要用来协调其它线程达到安全点
    // 需要达到安全点的线程主要有: 
    // Stop the world 的 GC
    // 做 thread dump
    // 线程挂起以及偏向锁的撤销
    "VM Thread" os_prio=0 tid=0x00007f7bc806f000 nid=0x405c runnable
    
    // 该线程是JVM周期性任务调度的线程
    // 该线程在JVM内使用得比较频繁
    // 比如：定期的内存监控、JVM运行状况监控
    "VM Periodic Task Thread" os_prio=0 tid=0x00007f7bc80bb800 nid=0x4063 waiting on condition
    
    JNI global references: 5
    
    
    Found one Java-level deadlock:
    =============================
    "TaskB":
      waiting to lock monitor 0x00007f7ba8006568 (object 0x00000000e525c690, a java.lang.Object),
      which is held by "TaskA"
    "TaskA":
      waiting to lock monitor 0x00007f7ba80050c8 (object 0x00000000e525c6a0, a java.lang.Object),
      which is held by "TaskB"
    
    Java stack information for the threads listed above:
    ===================================================
    "TaskB":
    	at LockExample$TaskB.run(LockExample.java:43)
    	- waiting to lock <0x00000000e525c690> (a java.lang.Object)
    	- locked <0x00000000e525c6a0> (a java.lang.Object)
    	at java.lang.Thread.run(Thread.java:748)
    "TaskA":
    	at LockExample$TaskA.run(LockExample.java:19)
    	- waiting to lock <0x00000000e525c6a0> (a java.lang.Object)
    	- locked <0x00000000e525c690> (a java.lang.Object)
    	at java.lang.Thread.run(Thread.java:748)
    
    Found 1 deadlock.

### 6.3.7 远程主机信息收集-jstatd命令

一个RMI服务端程序，相当于代理服务器，建立本地计算机与远程计算机的通讯，它用于将本地Java程序的信息传递到远程计算机。

直接启动会由于jstatd没有足够权限导致如下错误：

    # jstatd
    Could not create remote object
    access denied ("java.util.PropertyPermission" "java.rmi.server.ignoreSubClasses" "write")
    java.security.AccessControlException: access denied ("java.util.PropertyPermission" "java.rmi.server.ignoreSubClasses" "write")
    	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
    	at java.security.AccessController.checkPermission(AccessController.java:884)
    	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
    	at java.lang.System.setProperty(System.java:792)
    	at sun.tools.jstatd.Jstatd.main(Jstatd.java:139)

步骤: 
1. 使用Java安全策略分配权限

        // 建立如下文件
        # cat jstatd.all.policy
        grant codebase "file:/usr/local/java/jdk1.8.0_201/lib/tools.jar" {
            permission java.security.AllPermission;
        };

2. 再次启动jstatd
   
        // 使用公网IP
        // -J参数是一个公共参数，可以设置Java程序的虚拟机参数
        jstatd \
        -J-Djava.security.policy=/usr/local/java/jdk1.8.0_201/bin/jstatd.all.policy \
        -J-Djava.rmi.server.hostname=39.107.235.147 \
        &

3. 查看监听端口

        // 开启服务器入访端口1099和46097
        # netstat -anp | grep jstatd
        tcp6       0      0 :::1099                 :::*                    LISTEN      21239/jstatd
        tcp6       0      0 :::46097                :::*                    LISTEN      21239/jstatd
        tcp6       0      1 172.17.28.127:55708     39.107.235.147:46097    SYN_SENT    21239/jstatd
        unix  2      [ ]         STREAM     CONNECTED     358282   21239/jstatd
        unix  2      [ ]         STREAM     CONNECTED     358285   21239/jstatd

4. 本机访问

        jps -lvm 39.107.235.147
        21239 sun.tools.jstatd.Jstatd -Denv.class.path=.:/usr/local/java/jdk1.8.0_201/lib:/usr/local/java/jdk1.8.0_201/jre/lib -Dapplication.home=/usr/local/java/jdk1.8.0_201 -Xms8m -Djava.security.policy=/usr/local/java/jdk1.8.0_201/bin/jstatd.all.policy -Djava.rmi.server.hostname=39.107.235.147
        21279 Example -Xms320m -Xmx320m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC

        jstat -gcutil 21279@39.107.235.147 1s
          S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
          0.00   0.00  78.79  99.89  51.54  51.68      5    0.087     3    0.055    0.142
          0.00   0.00  81.27  99.89  51.54  51.68      5    0.087     3    0.055    0.142
          0.00   0.00  83.76  99.89  51.54  51.68      5    0.087     3    0.055    0.142

### 6.3.8 多功能命令行-jcmd命令

多功能命令行工具，可以用来查看Java进程、导出堆、导出线程信息、执行GC等。

    // 列出Java进程 
    # jcmd -l
    21604 sun.tools.jcmd.JCmd -l
    21239 sun.tools.jstatd.Jstatd
    21528 Example

    // 查看Java进程支持的命令
    # jcmd 21528 help
    21528:
    The following commands are available:
    JFR.stop
    JFR.start
    JFR.dump
    JFR.check
    VM.native_memory
    VM.check_commercial_features
    VM.unlock_commercial_features
    ManagementAgent.stop
    ManagementAgent.start_local
    ManagementAgent.start
    VM.classloader_stats
    GC.rotate_log
    Thread.print
    GC.class_stats
    GC.class_histogram
    GC.heap_dump
    GC.finalizer_info
    GC.heap_info
    GC.run_finalization
    GC.run
    VM.uptime
    VM.dynlibs
    VM.flags
    VM.system_properties
    VM.command_line
    VM.version
    help

    // 虚拟机版本
    # jcmd 22015 VM.version
    22015:
    Java HotSpot(TM) 64-Bit Server VM version 25.201-b09
    JDK 8.0_201
    
    // 虚拟机运行时间
    # jcmd 22015 VM.uptime
    22015:
    125.364 s
    
    // 虚拟机启动参数
    # jcmd 22015 VM.flags
    22015:
    -XX:CICompilerCount=2 -XX:InitialHeapSize=335544320 -XX:MaxHeapSize=335544320 -XX:MaxNewSize=111673344 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111673344 -XX:OldSize=223870976 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelOldGC
    
    // 系统属性
    # jcmd 22015 VM.system_properties
    22015:
    #Fri Feb 25 16:07:11 CST 2022
    java.runtime.name=Java(TM) SE Runtime Environment
    sun.boot.library.path=/usr/local/java/jdk1.8.0_201/jre/lib/amd64
    java.vm.version=25.201-b09
    ...
    
    // 命令行参数
    # jcmd 22015 VM.command_line
    22015:
    VM Arguments:
    jvm_args: -Xms320m -Xmx320m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC
    java_command: Example
    java_class_path (initial): .:/usr/local/java/jdk1.8.0_201/lib:/usr/local/java/jdk1.8.0_201/jre/lib
    Launcher Type: SUN_STANDARD
    
    // 执行GC
    # jcmd 22015 GC.run
    22015:
    Command executed successfully
    
    // 堆信息
    # jcmd 22015 GC.heap_info
    22015:
     PSYoungGen      total 95744K, used 12882K [0x00000000f9580000, 0x0000000100000000, 0x0000000100000000)
      eden space 82432K, 15% used [0x00000000f9580000,0x00000000fa214910,0x00000000fe600000)
      from space 13312K, 0% used [0x00000000ff300000,0x00000000ff300000,0x0000000100000000)
      to   space 13312K, 0% used [0x00000000fe600000,0x00000000fe600000,0x00000000ff300000)
     ParOldGen       total 218624K, used 195159K [0x00000000ec000000, 0x00000000f9580000, 0x00000000f9580000)
      object space 218624K, 89% used [0x00000000ec000000,0x00000000f7e95f40,0x00000000f9580000)
     Metaspace       used 3048K, capacity 4486K, committed 4864K, reserved 1056768K
      class space    used 333K, capacity 386K, committed 512K, reserved 1048576K
    
    // 类统计信息
    # jcmd 22015 GC.class_histogram
    22015:
    
     num     #instances         #bytes  class name
    ----------------------------------------------
       1:           597      211939432  [B
       2:          3271         195208  [C
       3:          3260          78240  java.lang.String
       4:           566          64336  java.lang.Class
       5:           550          33616  [Ljava.lang.Object;
       6:           615          24600  java.util.LinkedHashMap$Entry
       7:           284          13000  [Ljava.lang.String;
       8:           320          10240  java.util.HashMap$Node
       9:            17           7888  [Ljava.util.HashMap$Node;
      10:           115           6480  [I
      11:           202           4848  Example$User
      12:           256           4096  java.lang.Integer
     ...
     201:             1             16  sun.util.resources.LocaleData
     202:             1             16  sun.util.resources.LocaleData$LocaleDataResourceBundleControl
    Total         11095      212427712
    
    // 线程dump
    # jcmd 22015 Thread.print > thread.dump
    
    // 堆dump
    # jcmd 22188 GC.heap_dump ./bbb.bin
    
### 6.3.9 性能统计工具-hprof

一个Java agent工具，监控CPU信息和堆信息。

    // 查看帮助
    # java -agentlib:hprof=help

### 6.3.10 扩展jps命令

略。

## 6.4 图形化虚拟机监控工具-JConsole

略。

## 6.5 可视化性能监控工具-Visual VM

Visual VM 可以直接监控本机Java进程，也支持远程JMX连接。  
远程的Java应用可以通过如下参数打开JMX端口: 

    java -Xms1024m -Xmx1024m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC \
    -Dcom.sun.management.jmxremote \
    -Dcom.sun.management.jmxremote.ssl=false \
    -Dcom.sun.management.jmxremote.authenticate=false \
    -Dcom.sun.management.jmxremote.port=9999 \
    -Djava.rmi.server.hostname=39.107.235.147 \
    Example

通过如下命令查看JMX监听的3个端口(9999,37925,41203)，在远程服务器上打开它们的的网络入访规则。

    # netstat -anp | grep java
    tcp6       0      0 :::37925                :::*                    LISTEN      45531/java
    tcp6       0      0 :::9999                 :::*                    LISTEN      45531/java
    tcp6       0      0 :::41203                :::*                    LISTEN      45531/java
    tcp6       0      0 172.17.28.127:41203     36.110.31.130:53426     ESTABLISHED 45531/java
    unix  2      [ ]         STREAM     CONNECTED     838854   45531/java
    unix  2      [ ]         STREAM     CONNECTED     840224   45531/java
    unix  2      [ ]         STREAM     CONNECTED     840223   45531/java

本地启动Visual VM应用，添加远程主机，添加JMX连接即可看到远程Java进程。

如果需要使用Visual GC插件，远程服务器需要启动jstatd服务: 

    # jstatd -J-Djava.security.policy=/usr/local/java/jdk1.8.0_201/bin/jstatd.all.policy -J-Djava.rmi.server.hostname=39.107.235.147 &

## 6.6 虚拟机诊断工具-Mission Console

## 完