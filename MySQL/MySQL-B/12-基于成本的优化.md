# 12-基于成本的优化

## 12.1 什么是成本

查询语句的执行成本由两个方面组成：
- I/O成本
- CPU成本

对于InnoDB存储引擎来说，MySQL规定：
- 从磁盘读取一个页面花费的成本默认是`1.0`。
- 从内存读取以及检测一条记录是否符合搜索条件的成本默认是`0.2`。

这些数字称之为成本常数。

## 12.2 单表查询的成本

### 12.2.1 准备工作

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;

### 12.2.2 基于成本的优化步骤

一条单表查询语句执行之前，查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，过程是这样：
1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价
3. 计算使用不同索引执行查询的代价
4. 对比各种执行方案的代价，找出成本最低的那一个

详细分析计算过程省略。

`SHOW TABLE STATUS`语句来查看表的统计信息:
- Rows - 表中的记录条数  
  对于使用`MyISAM`存储引擎的表来说，该值是准确的。  
  对于使用`InnoDB`存储引擎的表来说，该值是一个估计值。

- Data_length - 表占用的存储空间字节数  
  聚簇索引的页面数量 = Data_length ÷ 16 ÷ 1024

      mysql> SHOW TABLE STATUS LIKE 'single_table'\G
      *************************** 1. row ***************************
                 Name: single_table
               Engine: InnoDB
              Version: 10
           Row_format: Dynamic
                 Rows: 9950
       Avg_row_length: 159
          Data_length: 1589248
      Max_data_length: 0
         Index_length: 1081344
            Data_free: 4194304
       Auto_increment: 10052
          Create_time: 2022-05-07 12:32:05
          Update_time: 2022-05-07 14:21:07
           Check_time: NULL
            Collation: utf8_general_ci
             Checksum: NULL
       Create_options:
              Comment:
      1 row in set (0.00 sec)


### 12.2.3 基于索引统计数据的成本计算

上面计算使用索引执行查询的代价时，确定一个单点区间对应的二级索引记录的条数有多少，是先获取索引对应的B+树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录。

MySQL把这种通过直接访问索引对应的B+树来计算某个范围区间对应的索引记录条数的方式称之为`index dive`。

当查询条件中的单点区间太多时，`index dive`的性能损耗就大了。

MySQL提供了一个系统变量`eq_range_index_dive_limit`，当单点区间的数量大于等于该值时，就不再使用`index dive`了，而是使用索引统计数据来进行估算。

    mysql> SHOW VARIABLES LIKE '%dive%';
    +---------------------------+-------+
    | Variable_name             | Value |
    +---------------------------+-------+
    | eq_range_index_dive_limit | 200   |
    +---------------------------+-------+

像为每个表维护一份统计数据一样，MySQL也会为每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用`SHOW INDEX FROM 表名`的语法：

    mysql> SHOW INDEX FROM single_table;
    +--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
    | Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
    +--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
    | single_table |          0 | PRIMARY      |            1 | id          | A         |        9950 |     NULL | NULL   |      | BTREE      |         |               |
    | single_table |          0 | idx_key2     |            1 | key2        | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    | single_table |          1 | idx_key1     |            1 | key1        | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    | single_table |          1 | idx_key3     |            1 | key3        | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    | single_table |          1 | idx_key_part |            1 | key_part1   | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    | single_table |          1 | idx_key_part |            2 | key_part2   | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    | single_table |          1 | idx_key_part |            3 | key_part3   | A         |        9950 |     NULL | NULL   | YES  | BTREE      |         |               |
    +--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+

其中：

            Table: 索引所属表的名称。
       Non_unique: 索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为0，普通二级索引该列值为1。
         Key_name: 索引的名称。
     Seq_in_index: 索引列在索引中的位置，从1开始计数。比如对于联合索引idx_key_part，来说，key_part1、key_part2和key_part3对应的位置分别是1、2、3。
      Column_name: 索引列的名称。
        Collation: 索引列中的值是按照何种排序方式存放的，值为A时代表升序存放，为NULL时代表降序存放。
      Cardinality: 索引列中不重复值的数量。
         Sub_part: 对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前n个字符或字节建立索引，这个属性表示的就是那个n值。如果对完整的列建立索引的话，该属性的值就是NULL。
           Packed: 索引列如何被压缩，NULL值表示未被压缩。
             Null: 该索引列是否允许存储NULL值。
       Index_type: 使用索引的类型，我们最常见的就是BTREE，其实也就是B+树索引。
          Comment: 索引列注释信息。
    Index_comment: 索引注释信息。

当单点区间的数量太大时，使用索引统计数据，这里所指的索引统计数据指的是这两个值：
- 使用SHOW TABLE STATUS展示出的Rows值，也就是一个表中有多少条记录。
- 使用SHOW INDEX语句展示出的Cardinality属性。

可以计算索引列平均单个值的重复次数就是：

    一个值的重复次数 ≈ Rows ÷ Cardinality

需要回表的记录数就是：

    一个值的重复次数 x 单点区间的数量

## 12.3 连接查询的成本

### 12.3.1 准备工作

连接查询至少是要有两个表。

### 12.3.2 条件过滤（Condition Filtering）

MySQL中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，查询成本由两个部分构成：
- 单次查询驱动表的成本
- 多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）

对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`。  
扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。

在这两种情况下计算驱动表扇出值时需要靠猜：
- 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

MySQL把这个猜的过程称之为`condition filtering`。

### 12.3.3 两表连接的成本分析

连接查询的成本计算公式：

    连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

左连接和右连接查询的驱动表是固定的，最优的查询方案只需要：
- 分别为驱动表和被驱动表选择成本最低的访问方法。

内连接驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：
- 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
- 然后分别为驱动表和被驱动表选择成本最低的访问方法。

连接查询成本占大头的其实是`驱动表扇出数 x 单次访问被驱动表的成本`，所以优化重点其实是下边这两个部分：
- 尽量减少驱动表的扇出
- 对被驱动表的访问成本尽量低

在实际书写连接查询语句时要尽量在被驱动表的连接列上建立索引，这样就可以使用`ref访问方法`来降低访问被驱动表的成本了。

如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低。

### 12.3.4 多表连接的成本分析

多表连接可能产生出很多种连接顺序，查询优化器要每一种连接顺序的成本都计算一遍。

MySQL想了很多办法减少计算非常多种连接顺序的成本的方法：
- 提前结束某种顺序的成本评估

  计算过程中的成本已经大于之前的连接顺序的最小成本，则提前结束。

- 系统变量`optimizer_search_depth`

  MySQL提出了`optimizer_search_depth`系统变量，如果连接表的个数小于该值，就继续穷举分析每一种连接顺序的成本，否则只对与`optimizer_search_depth`值相同数量的表进行穷举分析。

- 根据某些规则压根儿就不考虑某些连接顺序

  MySQL提出了一些所谓的启发式规则（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序就不分析。系统变量`ptimizer_prune_level`控制到底是不是用这些启发式规则。

## 12.4 调节成本常数

前边已经介绍了两个成本常数：
- 读取一个页面花费的成本默认是1.0
- 检测一条记录是否符合搜索条件的成本默认是0.2

MySQL还支持好多成本常数，它们被存储到了mysql数据库的两个表中：

    mysql> SHOW TABLES FROM mysql LIKE '%cost%';
    +--------------------------+
    | Tables_in_mysql (%cost%) |
    +--------------------------+
    | engine_cost              |
    | server_cost              |
    +--------------------------+

在server层中执行的操作对应的成本常数存储在`server_cost`表中。  
而在存储引擎中执行的操作对应的成本常数存储在`engine_cost`表中。

### 12.4.1 mysql.server_cost表

    mysql> SELECT * FROM mysql.server_cost;
    +------------------------------+------------+---------------------+---------+
    | cost_name                    | cost_value | last_update         | comment |
    +------------------------------+------------+---------------------+---------+
    | disk_temptable_create_cost   |       NULL | 2022-04-12 11:01:41 | NULL    |
    | disk_temptable_row_cost      |       NULL | 2022-04-12 11:01:41 | NULL    |
    | key_compare_cost             |       NULL | 2022-04-12 11:01:41 | NULL    |
    | memory_temptable_create_cost |       NULL | 2022-04-12 11:01:41 | NULL    |
    | memory_temptable_row_cost    |       NULL | 2022-04-12 11:01:41 | NULL    |
    | row_evaluate_cost            |       NULL | 2022-04-12 11:01:41 | NULL    |
    +------------------------------+------------+---------------------+---------+

各列意义：
- cost_name - 表示成本常数的名称。
- cost_value - 表示成本常数对应的值。如果该列的值为NULL的话，意味着对应的成本常数会采用默认值。
- last_update - 表示最后更新记录的时间。
- comment - 注释。

其中：

| 成本常数名称                   | 默认值      | 描述              |
| ---------------------------- | ---------- | ----------------- |
| disk_temptable_create_cost   |       40.0 | 创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| disk_temptable_row_cost      |        1.0 | 向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| key_compare_cost             |        0.1 | 两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升filesort的成本，让优化器可能更倾向于使用索引完成排序而不是filesort。|
| memory_temptable_create_cost |        2.0 | 创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| memory_temptable_row_cost    |        0.2 | 向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。|
| row_evaluate_cost            |        0.2 | 这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。|

提示：  
MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。  
在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。  
创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。

修改某个成本常数：

    UPDATE mysql.server_cost SET cost_value = 0.4 WHERE cost_name = 'row_evaluate_cost';
    -- 让系统重新加载这个表的值
    FLUSH OPTIMIZER_COSTS;

### 12.4.2 mysql.engine_cost表

    mysql> SELECT * FROM mysql.engine_cost;
    +-------------+-------------+------------------------+------------+---------------------+---------+
    | engine_name | device_type | cost_name              | cost_value | last_update         | comment |
    +-------------+-------------+------------------------+------------+---------------------+---------+
    | default     |           0 | io_block_read_cost     |       NULL | 2022-04-12 11:01:41 | NULL    |
    | default     |           0 | memory_block_read_cost |       NULL | 2022-04-12 11:01:41 | NULL    |
    +-------------+-------------+------------------------+------------+---------------------+---------+

各列意义：
- engine_name - 指成本常数适用的存储引擎名称。如果该值为default，意味着对应的成本常数适用于所有的存储引擎。
- device_type - 指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，MySQL这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是0。
- cost_name - 表示成本常数的名称。
- cost_value - 表示成本常数对应的值。如果该列的值为NULL的话，意味着对应的成本常数会采用默认值。
- last_update - 表示最后更新记录的时间。
- comment - 注释。

其中：

| 成本常数名称                   | 默认值      | 描述              |
| ---------------------------- | ---------- | ----------------- |
| io_block_read_cost           |        1.0 | 从磁盘上读取一个块对应的成本。请注意我使用的是块，而不是页这个词儿。对于InnoDB存储引擎来说，一个页就是一个块，不过对于MyISAM存储引擎来说，默认是以4096字节作为一个块的。增大这个值会加重I/O成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。 |
| memory_block_read_cost       |        1.0 | 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。 |

从内存中和从磁盘上读取一个块的默认成本是一样的？

这主要是因为在MySQL目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以MySQL很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是1.0。

修改成本常数方法同上。

# 完