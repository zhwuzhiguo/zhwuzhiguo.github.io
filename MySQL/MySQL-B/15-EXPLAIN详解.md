# 15-EXPLAIN详解

一条查询语句经过查询优化器的各种基于成本和规则的优化会后生成一个执行计划，执行计划展示具体执行查询的方式，比如多表连接的顺序，每个表采用什么访问方法来执行查询等等。

MySQL提供了`EXPLAIN`语句来查看某个查询语句的执行计划。

下面是`EXPLAIN`语句输出的各列：

| 列名 | 描述 |
| ------------- | ----------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id |
| select_type   | SELECT关键字对应的那个查询的类型 |
| table         | 表名 |
| partitions    | 匹配的分区信息 |
| type          | 针对单表的访问方法 |
| possible_keys | 可能用到的索引 |
| key           | 实际上使用的索引 |
| key_len       | 实际使用到的索引长度 |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows          | 预估的需要读取的记录条数 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比 |
| Extra         | 一些额外的信息 |

示例表`s1`和`s2`结构如下：

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;

## 15.1 执行计划输出中各列详解

### 15.1.1 table

不论查询语句多复杂，包含多少个表，最后也是需要对每个表进行单表访问的，所以`EXPLAIN`语句输出的每条记录都对应着某个单表的访问方法，记录的`table`列代表该表的表名。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

### 15.1.2 id

查询语句中每出现一个`SELECT`关键字，就会为它分配一个唯一的`id`值。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

在连接查询中，每个表都会对应一条记录，这些记录的`id`值相同，出现在前边的表是驱动表，出现在后边的表是被驱动表。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

包含子查询的查询语句，涉及多个`SELECT`关键字，每个`SELECT`关键字都会对应一个唯一的id值。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

这里需要注意，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以直接查看执行计划就能知道查询优化器是否对某个包含子查询的语句进行了重写。

    -- s2物化后作为驱动表，s1作为被驱动表执行连接查询
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = 'a');
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    | id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref              | rows | filtered | Extra       |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    |  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL             | NULL |   100.00 | Using where |
    |  1 | SIMPLE       | s1          | NULL       | ref  | idx_key1      | idx_key1 | 303     | <subquery2>.key3 |    1 |   100.00 | NULL        |
    |  2 | MATERIALIZED | s2          | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL             | 9781 |    10.00 | Using where |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+

包含UNION子句的查询语句，每个`SELECT`关键字对应一个`id`值，不过还有点儿特别：  
`UNION`查询会把多个查询的结果集合并起来并对结果集中的记录进行去重，所以需要生成一个临时表来去重。  
`UNION ALL`不需要为最终的结果集去重，所以也不需要使用临时表。

    -- 在内部创建了一个名为<union1,2>的临时表
    mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id   | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1   | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    |  2   | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    | NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

    mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    |  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

### 15.1.3 select_type

一条大的查询语句里可以包含若干个`SELECT`关键字，每个`SELECT`关键字代表着一个小查询语句，每个`SELECT`关键字的`FROM`子句中都可以包含若干张表（连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个`SELECT`关键字中的表来说，它们的`id`值是相同的。

每个`SELECT`关键字代表的小查询都定义了一个`select_type`的属性。

- SIMPLE

查询语句中不包含`UNION`或者`子查询`的查询类型。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

- PRIMARY

对于包含`UNION`、`UNION ALL`或者`子查询`的大查询，是由几个小查询组成，其中最左边的那个查询就是`PRIMARY`。

    mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id   | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1   | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    |  2   | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    | NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

- UNION

对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询就是`UNION`。

- UNION RESULT

`UNION`查询使用临时表来完成去重工作，针对该临时表的查询就是`UNION RESULT`。

- SUBQUERY

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且子查询是`不相关子查询`，并且查询优化器决定采用将子查询物化的方案来执行该子查询时，该子查询就是`SUBQUERY`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

可以看到，外层查询是`PRIMARY`，子查询是`SUBQUERY`。

注意：  
`SUBQUERY`子查询会被物化，只需要执行一遍。

- DEPENDENT SUBQUERY

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是`相关子查询`，则该子查询就是`DEPENDENT SUBQUERY`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    | id | select_type        | table | partitions | type | possible_keys     | key      | key_len | ref          | rows | filtered | Extra       |
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key2,idx_key1 | idx_key2 | 5       | temp.s1.key2 |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+

注意：  
`DEPENDENT SUBQUERY`子查询可能会被执行多次。

- DEPENDENT UNION

在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖外层查询，那除了最左边的那个小查询外，其余的小查询就是`DEPENDENT UNION`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
    | id   | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
    |  1   | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9781 |   100.00 | Using where              |
    |  2   | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
    |  3   | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
    | NULL | UNION RESULT       | <union2,3> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+

这个大查询里包含了一个子查询，子查询里又是由`UNION`连起来的两个小查询。  
`SELECT key1 FROM s2 WHERE key1 = 'a'`这个小查询是子查询中第一个查询，所以它是`DEPENDENT SUBQUERY`。  
`SELECT key1 FROM s1 WHERE key1 = 'b'`这个小查询就是`DEPENDENT UNION`。

- DERIVED

对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询就是`DERIVED`。

    -- <derived2> 表示查询是针对派生表物化之后的表进行查询的
    mysql> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1;
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9781 |    33.33 | Using where |
    |  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

- MATERIALIZED

当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询就是`MATERIALIZED`。

    -- <subquery2> 说明该表是id为2对应的子查询执行之后产生的物化表
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+
    | id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref          | rows | filtered | Extra       |
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+
    |  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_key>    | <auto_key> | 303     | temp.s1.key1 |    1 |   100.00 | NULL        |
    |  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL         | 9781 |   100.00 | Using index |
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+


- UNCACHEABLE SUBQUERY

不常用。

- UNCACHEABLE UNION

不常用。

### 15.1.4 partitions

如果查询是基于分区表的话，会显示查询将访问的分区，一般情况查询语句的执行计划的`partitions`列的值都是`NULL`。

### 15.1.5 type

表示一个查询单表访问的方法。

- system

当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的（`MyISAM`、`Memory`），那么对该表的访问方法就是`system`。

    mysql> EXPLAIN SELECT * FROM test;
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | test  | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+

- const

当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE id = 5;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 = 10005;
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+

- eq_ref

在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是`eq_ref`。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9781 |   100.00 | NULL  |
    |  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | temp.s1.id |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+

- ref

当通过普通的二级索引列与常量进行等值匹配来查询某个表，那么对该表的访问方法就可能是`ref`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

- fulltext

全文索引。

- ref_or_null

当对普通二级索引进行等值匹配查询，并且该索引列的值也可以是NULL值时，那么对该表的访问方法就是`ref_or_null`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
    | id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+

- index_merge

一般情况下对于某个表的查询只能使用到一个索引，某些场景下可以使用`Intersection`、`Union`、`Sort-Union`这三种索引合并的方式来执行查询，就是`index_merge`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    | id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+

- unique_subquery

类似于两表连接中被驱动表的`eq_ref`访问方法，`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，
如果查询优化器决定将`IN`子查询转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询就是`unique_subquery`。

    -- 执行计划的第二条记录的type值就是unique_subquery，说明在执行子查询时会使用到id列的索引
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
    | id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+

    -- 类似 EXISTS 示例
    mysql> EXPLAIN SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE s2.id = s1.key2 AND s2.key1 = s1.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+
    | id | select_type        | table | partitions | type   | possible_keys    | key     | key_len | ref          | rows | filtered | Extra       |
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3         | NULL    | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | PRIMARY,idx_key1 | PRIMARY | 4       | temp.s1.key2 |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+

- index_subquery

`index_subquery`与`unique_subquery`类似，只不过访问子查询中的表时使用的是普通的索引。

    -- 使用普通索引不行
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT key1 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+
    | id | select_type        | table | partitions | type | possible_keys | key      | key_len | ref          | rows | filtered | Extra                    |
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL         | 9781 |   100.00 | Using where              |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | temp.s1.key1 |    1 |   100.00 | Using where; Using index |
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+

    -- 只有使用唯一索引才行
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT key2 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+
    | id | select_type        | table | partitions | type           | possible_keys     | key      | key_len | ref  | rows | filtered | Extra       |
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3          | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key2,idx_key1 | idx_key2 | 5       | func |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+

- range

如果使用索引获取某些范围区间的记录，那么就可能使用到`range`访问方法。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    3 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 > 1 AND key2 < 5;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key2      | idx_key2 | 5       | NULL |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

- index

当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`。

    -- 需要扫描全部的索引记录
    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9781 |    10.00 | Using where; Using index |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+

    -- 不需要扫描全部的索引记录
    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part1 = 'a';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+

- ALL

全表扫描。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

**总结：**  
一般来说，这些访问方法按照上面介绍的顺序性能依次变差。其中除了`All`这个访问方法外，其余的访问方法都能用到索引，除了`index_merge`访问方法外，其余的访问方法都最多只能用到一个索引。

### 15.1.6 possible_keys 和 key

`possible_keys`表示可能用到的索引。

`key`表示经过查询优化器计算使用不同索引的成本后，实际用到的索引。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    1 |     5.00 | Using where |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+

在使用`index`访问方法来查询某个表时，`possible_keys`列是空的，而`key`列展示的是实际使用到的索引：

    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9781 |    10.00 | Using where; Using index |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+

注意：  
`possible_keys`并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以尽量删除那些用不到的索引。

### 15.1.7 key_len

`key_len`列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：
- 对于使用固定长度类型的索引列，它实际占用的存储空间的最大长度就是该固定值。  
  对于指定字符集的变长类型的索引列，该列实际占用的最大存储空间就是：`该列最大长度 × 字符集存储单个字符的最大字节数`。  
  比如VARCHAR(100)，实际占用的最大存储空间就是100 × 3 = 300个字节。
- 如果该索引列可以存储`NULL`值，则`key_len`比不可以存储`NULL`值时多`1`个字节。
- 对于变长字段来说，都会有`2`个字节的空间来存储该变长列的实际长度。

示例：

    -- id列类型是INT，并且不可以为NULL值，所以是4
    mysql> EXPLAIN SELECT * FROM s1 WHERE id = 5;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+

    -- key2列类型是INT，可以为NULL值，所以是4+1=5
    mysql>  EXPLAIN SELECT * FROM s1 WHERE key2 = 10005;
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+

    -- key1列类型是变长VARCHAR(100)，utf8编码，可为NULL，所以是100×3+1+2=303
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

提示：  
InnoDB存储变长字段的实际长度可能占用1个字节或者2个字节。  
执行计划是在MySQL的server层中生成的，不是针对具体某个存储引擎的功能。  
`key_len`列主要是为了区分某个使用联合索引的查询具体用了几个索引列。  
比如下边使用联合索引的查询：

    -- 使用一个索引 303
    mysql> EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+

    -- 使用俩个索引 606
    mysql> EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 606     | const,const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+

### 15.1.8 ref

当使用索引列等值匹配的条件去执行查询时，也就是访问方法是如下这些的时候：
- const
- eq_ref
- ref
- ref_or_null
- unique_subquery
- index_subquery

`ref`列展示的就是与索引列作等值匹配的对象是什么，比如可以是一个常数或者是某个列。

    -- const: 常数
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

    -- temp.s1.id: 数据库temp的表s1的列id
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9781 |   100.00 | NULL  |
    |  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | temp.s1.id |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+

    -- func: 是一个函数
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9781 |   100.00 | NULL                  |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+

### 15.1.9 rows

如果使用全表扫描执行查询，`rows`代表`预计`需要扫描的行数。  
如果使用索引执行查询，`rows`代表`预计`扫描的索引记录行数。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'aaa19991';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    8 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    1 row in set, 1 warning (0.00 sec)

    mysql> SELECT * FROM s1 WHERE key1 > 'aaa19991';
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    | id    | key1     | key2  | key3     | key_part1 | key_part2 | key_part3 | common_field |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    |  9993 | aaa19992 | 19992 | bbb19992 | part19992 | part29992 | part39992 | common19992  |
    |  9994 | aaa19993 | 19993 | bbb19993 | part19993 | part29993 | part39993 | common19993  |
    |  9995 | aaa19994 | 19994 | bbb19994 | part19994 | part29994 | part39994 | common19994  |
    |  9996 | aaa19995 | 19995 | bbb19995 | part19995 | part29995 | part39995 | common19995  |
    |  9997 | aaa19996 | 19996 | bbb19996 | part19996 | part29996 | part39996 | common19996  |
    |  9998 | aaa19997 | 19997 | bbb19997 | part19997 | part29997 | part39997 | common19997  |
    |  9999 | aaa19998 | 19998 | bbb19998 | part19998 | part29998 | part39998 | common19998  |
    | 10000 | aaa19999 | 19999 | bbb19999 | part19999 | part29999 | part39999 | common19999  |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+

### 15.1.10 filtered

MySQL在计算驱动表扇出时采用的一个策略：
- 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条(注：因为使用索引搜索可以计算出符合条件的记录条数)。

示例：

    -- rows=1000 : 满足key1 > 'aaa19'的记录有1000条
    -- filtered=10.00 : 预测1000条记录中有10.00%的记录满足common_field = 'common19999'这个条件
    mysql> EXPLAIN  SELECT * FROM s1 WHERE key1 > 'aaa19' AND common_field = 'common19999';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL | 1000 |    10.00 | Using index condition; Using where |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+

对于单表查询filtered列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的filtered值。

    -- s1当作驱动表
    -- s2当作被驱动表
    -- 驱动表s1表的执行计划的rows列为9781
    -- 驱动表s1表的执行计划的filtered列为51.11
    -- 这意味着驱动表s1的扇出值就是: 9781 × 51.11% = 4999，说明还要对被驱动表执行大约4999次查询
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.key2 > 15000;
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref          | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key2,idx_key1 | NULL     | NULL    | NULL         | 9781 |    51.11 | Using where |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1          | idx_key1 | 303     | temp.s1.key1 |    1 |   100.00 | NULL        |
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+

### 15.1.11 Extra

用来说明一些额外信息。额外信息有好几十个，介绍一些常见的。

- No tables used

查询语句没有FROM子句。

    mysql> EXPLAIN SELECT 1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+

- Impossible WHERE

查询语句的`WHERE`子句永远为`FALSE`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE 1 != 1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+

- No matching min/max row

当查询列表处有`MIN`或者`MAX`聚集函数，但是并没有符合`WHERE`子句中的搜索条件的记录。

    mysql> EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+

- Using index

查询列表以及搜索条件中只包含属于某个索引的列，也就是可以使用索引覆盖。

    mysql> EXPLAIN SELECT id, key_part1, key_part2, key_part3 FROM s1 WHERE key_part1 = 'a';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+

    mysql> EXPLAIN SELECT id, key_part1, key_part2, key_part3 FROM s1 WHERE key_part2 = 'a';
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9781 |    10.00 | Using where; Using index |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+

- Using index condition

查询语句的执行过程中将要使用`索引条件下推`（`Index Condition Pushdown`）特性。

`索引条件下推`其实就是当某个搜索条件可以使用某个二级索引时，如果还有其他搜索条件也是针对该索引的索引列的条件，也可以直接通过该索引处理，
则`server层`把其他这些可处理的搜索条件也一并下推给`存储引擎层`，通过该二级索引一起判断条件是否全都满足，再决定是否回表将完整记录返回给`server层`。
这样处理能减少回表次数，提高性能。

    -- 1. server层首先调用存储引擎的接口定位 key1 > 'z' 的第一条记录。
    -- 2. 存储引擎定位到该条二级索引记录后，先不回表，先判断所有关于 idx_key1 索引的条件是否成立，也就是 key1 > 'z' 和 key1 LIKE '%a'是否成立：
    --    如果这些条件不成立，直接跳过该二级索引记录，去找下一条二级索引记录。
    --    如果这些条件成立，则执行回表操作，将完整的用户记录返回给server层。
    -- 3. server层再判断其他的搜索条件是否成立（本例没有其他的搜索条件）：
    --    如果成立则将其发送给客户端。
    --    否则跳过该记录，然后向存储引擎层要下一条记录。
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%b';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

    -- 即使没有其他搜索条件，也是按索引条件下推处理，再判断一遍 key1 > 'z'
    -- 可能是为了编码处理一致
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

    -- 但针对等值匹配条件，是不按索引条件下推处理的
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

注意：  
`索引条件下推`只是为了在扫描某个范围区间的二级索引记录时尽可能减少回表次数，只适用于二级索引。

- Using where

当搜索条件需要在`server层`进行判断时。

    mysql> EXPLAIN SELECT * FROM s1 WHERE common_field = 'a';
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |    10.00 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |    10.00 | Using where |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+

- Using join buffer (Block Nested Loop)

连接查询中，当被驱动表不能有效的利用索引加快访问速度，一般会为其分配一块名叫`join buffer`的内存块来加快查询速度，也就是`基于块的嵌套循环算法`。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                               |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

- Not exists

当我们使用左连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件，而那个列又是不允许存储`NULL`值的。

    mysql> EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref          | rows | filtered | Extra                   |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL         | 9781 |   100.00 | NULL                    |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | temp.s1.key1 |    1 |    10.00 | Using where; Not exists |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------------------+

- Using intersect(...)、Using union(...) 和 Using sort_union(...)

`Using intersect(...)` - 说明准备使用Intersect索引合并的方式执行查询，括号中的...表示需要进行索引合并的索引名称。  
`Using union(...)` - 说明准备使用Union索引合并的方式执行查询。  
`Using sort_union(...)` - 说明准备使用Sort-Union索引合并的方式执行查询。  
括号中的`...`表示需要进行索引合并的索引名称。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    | id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+

- Zero limit

当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读出任何记录。

    mysql> EXPLAIN SELECT * FROM s1 LIMIT 0;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra      |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+
    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Zero limit |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+

- Using filesort

有一些情况下对结果集中的记录进行排序是可以使用到索引的。  
但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序。  
这种在内存中或者磁盘上进行排序的方式统称为`文件排序`（`filesort`）。

    -- 利用索引排序
    mysql> EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+

    -- 记录太多回表随机IO成本太高
    -- 全表扫描然后文件排序
    mysql> EXPLAIN SELECT * FROM s1 ORDER BY key1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using filesort |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+

    -- 无法利用索引，文件排序
    mysql> EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using filesort |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+

注意：  
如果查询中需要使用`filesort`的方式进行排序的记录非常多，会很耗费性能的，最好使用索引进行排序。

- Using temporary

查询中使用到了内部的临时表。

查询执行过程中可能会借助临时表来完成一些功能，比如去重、排序之类的。
执行许多包含`DISTINCT`、`GROUP BY`、`UNION`等子句的查询过程中，如果不能有效利用索引来完成查询，就很有可能通过建立内部的临时表来执行查询。

    -- 使用临时表去重
    mysql> EXPLAIN SELECT DISTINCT common_field FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using temporary |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+

    -- MySQL会在包含GROUP BY子句的查询中默认添加上ORDER BY子句
    mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using temporary; Using filesort |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+

    -- 如果不想为包含GROUP BY子句的查询进行排序，需要显式的写上ORDER BY NULL
    mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY NULL;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using temporary |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+

建立与维护临时表要付出很大成本的，最好能使用索引来替代掉使用临时表。

    -- 使用索引而不是临时表
    mysql> EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

- Start temporary, End temporary

在将`In`子查询转为`semi-join`时，如果采用的是`DuplicateWeedout`执行策略，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，
驱动表执行计划显示`Start temporary`，被驱动表执行计划显示`End temporary`。

    -- 没有测试出来
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = 'a');
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    | id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref              | rows | filtered | Extra       |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    |  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL             | NULL |   100.00 | Using where |
    |  1 | SIMPLE       | s1          | NULL       | ref  | idx_key1      | idx_key1 | 303     | <subquery2>.key3 |    1 |   100.00 | NULL        |
    |  2 | MATERIALIZED | s2          | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL             | 9781 |    10.00 | Using where |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+

- LooseScan

在将`In`子查询转为`semi-join`时，如果采用的是`LooseScan`执行策略，驱动表执行计划显示`LooseScan`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 > 'z');
    +----+-------------+-------+------------+-------+---------------+----------+---------+--------------+------+----------+-------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref          | rows | filtered | Extra                               |
    +----+-------------+-------+------------+-------+---------------+----------+---------+--------------+------+----------+-------------------------------------+
    |  1 | SIMPLE      | s2    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL         |    1 |   100.00 | Using where; Using index; LooseScan |
    |  1 | SIMPLE      | s1    | NULL       | ref   | idx_key3      | idx_key3 | 303     | temp.s2.key1 |    1 |   100.00 | NULL                                |
    +----+-------------+-------+------------+-------+---------------+----------+---------+--------------+------+----------+-------------------------------------+

- FirstMatch(table_name)

在将`In`子查询转为`semi-join`时，如果采用的是`FirstMatch`执行策略，被驱动表执行计划显示`FirstMatch(table_name)`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key1 FROM s2 WHERE s1.key3 = s2.key3);
    +----+-------------+-------+------------+------+-------------------+----------+---------+----------------------+------+----------+-----------------------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref                  | rows | filtered | Extra                       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+----------------------+------+----------+-----------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL                 | 9781 |   100.00 | Using where                 |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1,idx_key3 | idx_key1 | 303     | temp.s1.common_field |    1 |     5.00 | Using where; FirstMatch(s1) |
    +----+-------------+-------+------------+------+-------------------+----------+---------+----------------------+------+----------+-----------------------------+

## 15.2 JSON格式的执行计划

查看某个执行计划花费的成本的方式：  
在`EXPLAIN`单词和真正的查询语句中间加上`FORMAT=JSON`。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-----------------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref          | rows | filtered | Extra                 |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL         | 9781 |    10.00 | Using where           |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key2      | idx_key2 | 5       | temp.s1.key1 |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-----------------------+

    mysql> EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
    *************************** 1. row ***************************
    EXPLAIN: {
      "query_block": {
        "select_id": 1,             # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1
        "cost_info": {
          "query_cost": "3226.92"   # 整个查询的执行成本预计为3226.92
        },
        "nested_loop": [            # 几个表之间采用嵌套循环连接算法执行
          {
            "table": {
              "table_name": "s1",   # s1表是驱动表
              "access_type": "ALL", # 访问方法为ALL，意味着使用全表扫描访问
              "possible_keys": [    # 可能使用的索引
                "idx_key1"
              ],
              "rows_examined_per_scan": 9781, # 查询一次s1表大致需要扫描9781条记录
              "rows_produced_per_join": 978,  # 驱动表s1的扇出是978
              "filtered": "10.00",            # condition filtering代表的百分比
              "cost_info": {
                "read_cost": "1857.58",       # 稍后解释
                "eval_cost": "195.62",        # 稍后解释
                "prefix_cost": "2053.20",     # 单次查询s1表总共的成本
                "data_read_per_join": "1M"    # 读取的数据量
              },
              "used_columns": [               # 执行查询中涉及到的列
                "id",
                "key1",
                "key2",
                "key3",
                "key_part1",
                "key_part2",
                "key_part3",
                "common_field"
              ],
              "attached_condition": "((`temp`.`s1`.`common_field` = 'a') and (`temp`.`s1`.`key1` is not null))" # 对s1表访问时针对单表查询的条件
            }
          },
          {
            "table": {
              "table_name": "s2",     # s2表是被驱动表
              "access_type": "ref",   # 访问方法为ref，意味着使用索引等值匹配的方式访问
              "possible_keys": [      # 可能使用的索引
                "idx_key2"
              ],
              "key": "idx_key2",      # 实际使用的索引
              "used_key_parts": [     # 使用到的索引列
                "key2"
              ],
              "key_length": "5",      # key_len
              "ref": [                # 与key2列进行等值匹配的对象
                "temp.s1.key1"
              ],
              "rows_examined_per_scan": 1,    # 查询一次s2表大致需要扫描1条记录
              "rows_produced_per_join": 978,  # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）
              "filtered": "100.00",
              "index_condition": "(`temp`.`s1`.`key1` = `temp`.`s2`.`key2`)",  # s2表使用索引进行查询的搜索条件
              "cost_info": {
                "read_cost": "978.10",          # 稍后解释
                "eval_cost": "195.62",          # 稍后解释
                "prefix_cost": "3226.92",       # 单次查询s1、多次查询s2表总共的成本
                "data_read_per_join": "1M"      # 读取的数据量
              },
              "used_columns": [                 # 执行查询中涉及到的列
                "id",
                "key1",
                "key2",
                "key3",
                "key_part1",
                "key_part2",
                "key_part3",
                "common_field"
              ]
            }
          }
        ]
      }
    }

s1表的"cost_info"部分：

    "cost_info": {
    "read_cost": "1857.58",       # 稍后解释
    "eval_cost": "195.62",        # 稍后解释
    "prefix_cost": "2053.20",     # 单次查询s1表总共的成本
    "data_read_per_join": "1M"    # 读取的数据量
    },

- read_cost是由下边这两部分组成的：  
  - IO成本
  - 检测rows × (1 - filter)条记录的CPU成本

- eval_cost是这样计算的：  
  检测 rows × filter条记录的成本。

- prefix_cost就是单独查询s1表的成本，也就是：  
  read_cost + eval_cost

- data_read_per_join表示在此次查询中需要读取的数据量。

对于s2表的"cost_info"部分：

    "cost_info": {
    "read_cost": "978.10",          # 稍后解释
    "eval_cost": "195.62",          # 稍后解释
    "prefix_cost": "3226.92",       # 单次查询s1、多次查询s2表总共的成本
    "data_read_per_join": "1M"      # 读取的数据量
    },

由于s2表是被驱动表，所以可能被读取多次，read_cost和eval_cost是访问多次s2表后累加起来的值。  

主要关注prefix_cost的值代表的是整个连接查询预计的成本，也就是单次查询s1表和多次查询s2表后的成本的和：
 
    978.10 + 195.62 + 2053.20 = 3226.92


## 15.3 Extented EXPLAIN

在使用`EXPLAIN`语句查看了某个查询的执行计划后，紧接着还可以使用`SHOW WARNINGS`语句查看与这个查询的执行计划有关的一些扩展信息。

    mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref          | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------+
    |  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL         | 9781 |    90.00 | Using where |
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | temp.s2.key1 |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+-------------+
    
    mysql> SHOW WARNINGS\G
    *************************** 1. row ***************************
      Level: Note
       Code: 1003
    Message: /* select#1 */ select `temp`.`s1`.`key1` AS `key1`,`temp`.`s2`.`key1` AS `key1` from `temp`.`s1` join `temp`.`s2` where ((`temp`.`s1`.`key1` = `temp`.`s2`.`key1`) and (`temp`.`s2`.`common_field` is not null))
    1 row in set (0.00 sec)

常见的是`Code`为`1003`的信息，`Message`字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。

`Message`字段展示的信息并不是标准的查询语句，只能作为帮助理解查MySQL将如何执行查询语句的一个参考。

# 完