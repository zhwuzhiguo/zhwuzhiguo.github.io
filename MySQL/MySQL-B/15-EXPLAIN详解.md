# 15-EXPLAIN详解

一条查询语句经过查询优化器的各种基于成本和规则的优化会后生成一个执行计划，执行计划展示具体执行查询的方式，比如多表连接的顺序，每个表采用什么访问方法来执行查询等等。

MySQL提供了`EXPLAIN`语句来查看某个查询语句的执行计划。

下面是`EXPLAIN`语句输出的各列：

| 列名 | 描述 |
| ------------- | ----------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id |
| select_type   | SELECT关键字对应的那个查询的类型 |
| table         | 表名 |
| partitions    | 匹配的分区信息 |
| type          | 针对单表的访问方法 |
| possible_keys | 可能用到的索引 |
| key           | 实际上使用的索引 |
| key_len       | 实际使用到的索引长度 |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows          | 预估的需要读取的记录条数 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比 |
| Extra         | 一些额外的信息 |

示例表`s1`和`s2`结构如下：

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;

## 15.1 执行计划输出中各列详解

### 15.1.1 table

不论查询语句多复杂，包含多少个表，最后也是需要对每个表进行单表访问的，所以`EXPLAIN`语句输出的每条记录都对应着某个单表的访问方法，记录的`table`列代表该表的表名。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

### 15.1.2 id

查询语句中每出现一个`SELECT`关键字，就会为它分配一个唯一的`id`值。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

在连接查询中，每个表都会对应一条记录，这些记录的`id`值相同，出现在前边的表是驱动表，出现在后边的表是被驱动表。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

包含子查询的查询语句，涉及多个`SELECT`关键字，每个`SELECT`关键字都会对应一个唯一的id值。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

这里需要注意，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以直接查看执行计划就能知道查询优化器是否对某个包含子查询的语句进行了重写。

    -- s2物化后作为驱动表，s1作为被驱动表执行连接查询
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = 'a');
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    | id | select_type  | table       | partitions | type | possible_keys | key      | key_len | ref              | rows | filtered | Extra       |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
    |  1 | SIMPLE       | <subquery2> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL             | NULL |   100.00 | Using where |
    |  1 | SIMPLE       | s1          | NULL       | ref  | idx_key1      | idx_key1 | 303     | <subquery2>.key3 |    1 |   100.00 | NULL        |
    |  2 | MATERIALIZED | s2          | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL             | 9781 |    10.00 | Using where |
    +----+--------------+-------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+

包含UNION子句的查询语句，每个`SELECT`关键字对应一个`id`值，不过还有点儿特别：  
`UNION`查询会把多个查询的结果集合并起来并对结果集中的记录进行去重，所以需要生成一个临时表来去重。  
`UNION ALL`不需要为最终的结果集去重，所以也不需要使用临时表。

    -- 在内部创建了一个名为<union1,2>的临时表
    mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id   | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1   | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    |  2   | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    | NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

    mysql> EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    |  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

### 15.1.3 select_type

一条大的查询语句里可以包含若干个`SELECT`关键字，每个`SELECT`关键字代表着一个小查询语句，每个`SELECT`关键字的`FROM`子句中都可以包含若干张表（连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个`SELECT`关键字中的表来说，它们的`id`值是相同的。

每个`SELECT`关键字代表的小查询都定义了一个`select_type`的属性。

- SIMPLE

查询语句中不包含`UNION`或者`子查询`的查询类型。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL                                  |
    |  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+

- PRIMARY

对于包含`UNION`、`UNION ALL`或者`子查询`的大查询，是由几个小查询组成，其中最左边的那个查询就是`PRIMARY`。

    mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    | id   | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
    |  1   | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    |  2   | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL            |
    | NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
    +------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

- UNION

对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询就是`UNION`。

- UNION RESULT

`UNION`查询使用临时表来完成去重工作，针对该临时表的查询就是`UNION RESULT`。

- SUBQUERY

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且子查询是`不相关子查询`，并且查询优化器决定采用将子查询物化的方案来执行该子查询时，该子查询就是`SUBQUERY`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

可以看到，外层查询是`PRIMARY`，子查询是`SUBQUERY`。

注意：  
`SUBQUERY`子查询会被物化，只需要执行一遍。

- DEPENDENT SUBQUERY

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是`相关子查询`，则该子查询就是`DEPENDENT SUBQUERY`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    | id | select_type        | table | partitions | type | possible_keys     | key      | key_len | ref          | rows | filtered | Extra       |
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key2,idx_key1 | idx_key2 | 5       | temp.s1.key2 |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+

注意：  
`DEPENDENT SUBQUERY`子查询可能会被执行多次。

- DEPENDENT UNION

在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖外层查询，那除了最左边的那个小查询外，其余的小查询就是`DEPENDENT UNION`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
    | id   | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
    |  1   | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9781 |   100.00 | Using where              |
    |  2   | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
    |  3   | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | Using where; Using index |
    | NULL | UNION RESULT       | <union2,3> | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |
    +------+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+

这个大查询里包含了一个子查询，子查询里又是由`UNION`连起来的两个小查询。  
`SELECT key1 FROM s2 WHERE key1 = 'a'`这个小查询是子查询中第一个查询，所以它是`DEPENDENT SUBQUERY`。  
`SELECT key1 FROM s1 WHERE key1 = 'b'`这个小查询就是`DEPENDENT UNION`。

- DERIVED

对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询就是`DERIVED`。

    -- <derived2> 表示查询是针对派生表物化之后的表进行查询的
    mysql> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1;
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    | id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9781 |    33.33 | Using where |
    |  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9781 |   100.00 | Using index |
    +----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+

- MATERIALIZED

当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询就是`MATERIALIZED`。

    -- <subquery2> 说明该表是id为2对应的子查询执行之后产生的物化表
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+
    | id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref          | rows | filtered | Extra       |
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+
    |  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  1 | SIMPLE       | <subquery2> | NULL       | eq_ref | <auto_key>    | <auto_key> | 303     | temp.s1.key1 |    1 |   100.00 | NULL        |
    |  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL         | 9781 |   100.00 | Using index |
    +----+--------------+-------------+------------+--------+---------------+------------+---------+--------------+------+----------+-------------+


- UNCACHEABLE SUBQUERY

不常用。

- UNCACHEABLE UNION

不常用。

### 15.1.4 partitions

如果查询是基于分区表的话，会显示查询将访问的分区，一般情况查询语句的执行计划的`partitions`列的值都是`NULL`。

### 15.1.5 type

表示一个查询单表访问的方法。

- system

当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的（`MyISAM`、`Memory`），那么对该表的访问方法就是`system`。

    mysql> EXPLAIN SELECT * FROM test;
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | test  | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+

- const

当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE id = 5;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 = 10005;
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+

- eq_ref

在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是`eq_ref`。

    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9781 |   100.00 | NULL  |
    |  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | temp.s1.id |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+

- ref

当通过普通的二级索引列与常量进行等值匹配来查询某个表，那么对该表的访问方法就可能是`ref`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

- fulltext

全文索引。

- ref_or_null

当对普通二级索引进行等值匹配查询，并且该索引列的值也可以是NULL值时，那么对该表的访问方法就是`ref_or_null`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
    | id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+

- index_merge

一般情况下对于某个表的查询只能使用到一个索引，某些场景下可以使用`Intersection`、`Union`、`Sort-Union`这三种索引合并的方式来执行查询，就是`index_merge`。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    | id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
    +----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+

- unique_subquery

类似于两表连接中被驱动表的`eq_ref`访问方法，`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，
如果查询优化器决定将`IN`子查询转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询就是`unique_subquery`。

    -- 执行计划的第二条记录的type值就是unique_subquery，说明在执行子查询时会使用到id列的索引
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
    | id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+

    -- 类似 EXISTS 示例
    mysql> EXPLAIN SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE s2.id = s1.key2 AND s2.key1 = s1.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+
    | id | select_type        | table | partitions | type   | possible_keys    | key     | key_len | ref          | rows | filtered | Extra       |
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3         | NULL    | NULL    | NULL         | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | PRIMARY,idx_key1 | PRIMARY | 4       | temp.s1.key2 |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+--------+------------------+---------+---------+--------------+------+----------+-------------+

- index_subquery

`index_subquery`与`unique_subquery`类似，只不过访问子查询中的表时使用的是普通的索引。

    -- 使用普通索引不行
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT key1 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+
    | id | select_type        | table | partitions | type | possible_keys | key      | key_len | ref          | rows | filtered | Extra                    |
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL         | 9781 |   100.00 | Using where              |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | temp.s1.key1 |    1 |   100.00 | Using where; Using index |
    +----+--------------------+-------+------------+------+---------------+----------+---------+--------------+------+----------+--------------------------+

    -- 只有使用唯一索引才行
    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT key2 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+
    | id | select_type        | table | partitions | type           | possible_keys     | key      | key_len | ref  | rows | filtered | Extra       |
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+
    |  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3          | NULL     | NULL    | NULL | 9781 |   100.00 | Using where |
    |  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key2,idx_key1 | idx_key2 | 5       | func |    1 |    10.00 | Using where |
    +----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+

- range

如果使用索引获取某些范围区间的记录，那么就可能使用到`range`访问方法。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    3 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 > 1 AND key2 < 5;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key2      | idx_key2 | 5       | NULL |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+

- index

当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`。

    -- 需要扫描全部的索引记录
    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9781 |    10.00 | Using where; Using index |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+

    -- 不需要扫描全部的索引记录
    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part1 = 'a';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |   100.00 | Using index |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+

- ALL

全表扫描。

    mysql> EXPLAIN SELECT * FROM s1;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9781 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+

**总结：**  
一般来说，这些访问方法按照上面介绍的顺序性能依次变差。其中除了`All`这个访问方法外，其余的访问方法都能用到索引，除了`index_merge`访问方法外，其余的访问方法都最多只能用到一个索引。

### 15.1.6 possible_keys 和 key

`possible_keys`表示可能用到的索引。

`key`表示经过查询优化器计算使用不同索引的成本后，实际用到的索引。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    1 |     5.00 | Using where |
    +----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+

在使用`index`访问方法来查询某个表时，`possible_keys`列是空的，而`key`列展示的是实际使用到的索引：

    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
    |  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9781 |    10.00 | Using where; Using index |
    +----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+

注意：  
`possible_keys`并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以尽量删除那些用不到的索引。

### 15.1.7 key_len

`key_len`列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：
- 对于使用固定长度类型的索引列，它实际占用的存储空间的最大长度就是该固定值。  
  对于指定字符集的变长类型的索引列，该列实际占用的最大存储空间就是：`该列最大长度 × 字符集存储单个字符的最大字节数`。  
  比如VARCHAR(100)，实际占用的最大存储空间就是100 × 3 = 300个字节。
- 如果该索引列可以存储`NULL`值，则`key_len`比不可以存储`NULL`值时多`1`个字节。
- 对于变长字段来说，都会有`2`个字节的空间来存储该变长列的实际长度。

示例：

    -- id列类型是INT，并且不可以为NULL值，所以是4
    mysql> EXPLAIN SELECT * FROM s1 WHERE id = 5;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+

    -- key2列类型是INT，可以为NULL值，所以是4+1=5
    mysql>  EXPLAIN SELECT * FROM s1 WHERE key2 = 10005;
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+

    -- key1列类型是变长VARCHAR(100)，utf8编码，可为NULL，所以是100×3+1+2=303
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

提示：  
InnoDB存储变长字段的实际长度可能占用1个字节或者2个字节。  
执行计划是在MySQL的server层中生成的，不是针对具体某个存储引擎的功能。  
`key_len`列主要是为了区分某个使用联合索引的查询具体用了几个索引列。  
比如下边使用联合索引的查询：

    -- 使用一个索引 303
    mysql> EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+

    -- 使用俩个索引 606
    mysql> EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 606     | const,const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+

### 15.1.8 ref

当使用索引列等值匹配的条件去执行查询时，也就是访问方法是如下这些的时候：
- const
- eq_ref
- ref
- ref_or_null
- unique_subquery
- index_subquery

`ref`列展示的就是与索引列作等值匹配的对象是什么，比如可以是一个常数或者是某个列。

    -- const: 常数
    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+

    -- temp.s1.id: 数据库temp的表s1的列id
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+
    |  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9781 |   100.00 | NULL  |
    |  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | temp.s1.id |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+

    -- func: 是一个函数
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9781 |   100.00 | NULL                  |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+

### 15.1.9 rows

如果使用全表扫描执行查询，`rows`代表`预计`需要扫描的行数。  
如果使用索引执行查询，`rows`代表`预计`扫描的索引记录行数。

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'aaa19991';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    8 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    1 row in set, 1 warning (0.00 sec)

    mysql> SELECT * FROM s1 WHERE key1 > 'aaa19991';
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    | id    | key1     | key2  | key3     | key_part1 | key_part2 | key_part3 | common_field |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    |  9993 | aaa19992 | 19992 | bbb19992 | part19992 | part29992 | part39992 | common19992  |
    |  9994 | aaa19993 | 19993 | bbb19993 | part19993 | part29993 | part39993 | common19993  |
    |  9995 | aaa19994 | 19994 | bbb19994 | part19994 | part29994 | part39994 | common19994  |
    |  9996 | aaa19995 | 19995 | bbb19995 | part19995 | part29995 | part39995 | common19995  |
    |  9997 | aaa19996 | 19996 | bbb19996 | part19996 | part29996 | part39996 | common19996  |
    |  9998 | aaa19997 | 19997 | bbb19997 | part19997 | part29997 | part39997 | common19997  |
    |  9999 | aaa19998 | 19998 | bbb19998 | part19998 | part29998 | part39998 | common19998  |
    | 10000 | aaa19999 | 19999 | bbb19999 | part19999 | part29999 | part39999 | common19999  |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+

### 15.1.10 filtered

MySQL在计算驱动表扇出时采用的一个策略：
- 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条(注：因为使用索引搜索可以计算出符合条件的记录条数)。

示例：

    -- rows=1000 : 满足key1 > 'aaa19'的记录有1000条
    -- filtered=10.00 : 预测1000条记录中有10.00%的记录满足common_field = 'common19999'这个条件
    mysql> EXPLAIN  SELECT * FROM s1 WHERE key1 > 'aaa19' AND common_field = 'common19999';
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
    |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL | 1000 |    10.00 | Using index condition; Using where |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+

对于单表查询filtered列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的filtered值。

    -- s1当作驱动表
    -- s2当作被驱动表
    -- 驱动表s1表的执行计划的rows列为9781
    -- 驱动表s1表的执行计划的filtered列为51.11
    -- 这意味着驱动表s1的扇出值就是: 9781 × 51.11% = 4999，说明还要对被驱动表执行大约4999次查询
    mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.key2 > 15000;
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref          | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+
    |  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key2,idx_key1 | NULL     | NULL    | NULL         | 9781 |    51.11 | Using where |
    |  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1          | idx_key1 | 303     | temp.s1.key1 |    1 |   100.00 | NULL        |
    +----+-------------+-------+------------+------+-------------------+----------+---------+--------------+------+----------+-------------+

### 15.1.11 Extra


## 15.2 JSON格式的执行计划
## 15.3 Extented EXPLAIN
## 15.4 总结

# 完