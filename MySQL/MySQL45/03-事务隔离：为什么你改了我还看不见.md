# 03-事务隔离：为什么你改了我还看不见

## 隔离性与隔离级别

提到事务，肯定会想到 `ACID`（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天就来说说其中 `I`，也就是 `隔离性` 。

当数据库上有多个事务同时执行的时候，就可能出现 `脏读`、`不可重复读`、`幻读` 的问题，为了解决这些问题，就有了 `隔离级别` 的概念。

SQL 标准的事务隔离级别包括：
- 读未提交（`read uncommitted`）  
  一个事务还没提交时，它做的变更就能被别的事务看到。

- 读提交（`read committed`）  
  一个事务提交之后，它做的变更才会被其他事务看到。

- 可重复读（`repeatable read`）  
  一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然未提交变更对其他事务也是不可见的。

- 串行化（`serializable`）  
  对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

查看当前事务隔离级别：

    mysql> SHOW VARIABLES LIKE 'transaction_isolation';
    +-----------------------+-----------------+
    | Variable_name         | Value           |
    +-----------------------+-----------------+
    | transaction_isolation | REPEATABLE-READ |
    +-----------------------+-----------------+

## 事务隔离的实现

事务隔离通过多版本并发控制（`MVCC`）实现。

由于回滚日志的存在，同一条记录在系统中可以存在多个版本。

不同时刻启动的事务会有不同的事务视图，能看到不同的记录版本。

尽量不要使用长事务，长事务里会存在很老的事务视图，可能访问数据的版本也就越老，也就需要保留更多的回滚日志，导致回滚日志不能及时删除占用大量的存储空间。

另外长事务也会长时间占用锁资源。

## 事务的启动方式

- 显式启动事务语句
  
  `begin` 或 `start transaction`。  
  配套的提交语句是 `commit`，回滚语句是 `rollback`。

- `set autocommit=0`
  
  这个命令会将这个线程的自动提交关掉。  
  意味着只执行一个 `select` 语句，事务就启动了，而且并不会自动提交。  
  事务持续存在直到你主动执行 `commit` 或 `rollback` 语句，或者断开连接。

建议通过显式语句的方式来启动事务。

可以在 `information_schema` 库的 `innodb_trx` 表中查询长事务。

    -- 查找持续时间超过 60s 的事务
    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60;


# 完