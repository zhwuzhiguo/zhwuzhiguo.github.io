# 34-到底可不可以使用join

关于 `join` 语句使用的问题：
- 使用 `join` 有什么问题呢？
- 两个大小不同的表做 `join` 应该用哪个表做驱动表呢？

准备数据：

```sql
-- 创建表 t2
CREATE TABLE t2 (
  id int(11) NOT NULL,
  a int(11) DEFAULT NULL,
  b int(11) DEFAULT NULL,
  PRIMARY KEY (id),
KEY a (a)
) ENGINE=InnoDB;

-- 插入数据存储过程
CREATE PROCEDURE insert_data()
BEGIN
  declare i int;
  set i=1;
  while(i<=1000) do
    insert into t2 values(i, i, i);
    set i=i+1;  
  end while;
END

-- 调用存储过程
CALL insert_data();

-- 创建表 t1
CREATE TABLE t1 LIKE t2;

-- t1 插入 t2 前 100 条记录
INSERT INTO t1 (SELECT * FROM t2 WHERE id <= 100);
```

## Index Nested-Loop Join

**可以使用被驱动表的索引的情况。**

如下语句：

    select * from t1 straight_join t2 on (t1.a=t2.a);

改用 `straight_join` 让 `MySQL` 使用固定的连接方式执行查询，这样优化器就不会调整驱动表和被驱动表。

在这个语句里 `t1` 是驱动表 `t2` 是被驱动表。

    mysql> explain select * from t1 straight_join t2 on (t1.a=t2.a);
    +----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref       | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+
    |  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL      |  100 |   100.00 | Using where |
    |  1 | SIMPLE      | t2    | NULL       | ref  | a             | a    | 5       | test.t1.a |    1 |   100.00 | NULL        |
    +----+-------------+-------+------------+------+---------------+------+---------+-----------+------+----------+-------------+

在这条语句里，被驱动表 `t2` 的字段 `a` 上有索引，`join` 过程用上了这个索引，执行流程是这样的：
- 从表 `t1` 中读入一行数据 `R`。
- 从数据行 `R` 中，取出 `a` 字段到表 `t2` 里去查找。
- 取出表 `t2` 中满足条件的行，跟 `R` 组成一行，作为结果集的一部分。
- 重复执行直到表 `t1` 的末尾循环结束。

这个过程是先遍历表 `t1`，然后根据从表 `t1` 中取出的每行数据中的 `a` 值，去表 `t2` 中查找满足条件的记录。

这个过程和程序里的嵌套查询类似，并且可以用上被驱动表的索引，所以称之为 `Index Nested-Loop Join`，简称 `NLJ`。

在这个流程里：
- 对驱动表 `t1` 做了全表扫描，这个过程需要扫描 `100` 行。
- 而对于每一行 `R`，根据 `a` 字段去表 `t2` 查找，走的是树搜索过程。由于构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 `100` 行。
- 所以整个执行流程，总扫描行数是 `200`。

假设不使用 `join` 而是单表查询：
- 执行 `select * from t1` 查出表 `t1` 的所有 `100` 行数据。
- 循环遍历这 `100` 行数据：
  - 从每一行 `R` 取出字段 `a` 的值 `$R.a`。
  - 每行数据执行 `select * from t2 where a=$R.a`。
  - 把返回的结果和 `R` 构成结果集的一行。

在这个查询过程，也是扫描了 `200` 行，但是总共执行了 `101` 条语句，比直接 `join` 多了 `100` 次交互。

显然这么做还不如直接 `join` 好。

而且使用`小表`做驱动表，扫描行数更少。

小结：

在可以使用被驱动表的索引的情况下：
- 使用 `join` 语句，性能比强行拆成多个单表执行 `SQL` 语句的性能要好。
- 使用 `join` 语句，要让`小表`做驱动表。

## Simple Nested-Loop Join

**不可以使用被驱动表的索引的情况。**

如下语句：

    select * from t1 straight_join t2 on (t1.a=t2.b);

由于表 `t2` 的字段 `b` 上没有索引，因此每次到 `t2` 去匹配的时候，就要做一次`全表扫描`。

这个算法也有一个名字叫做 `Simple Nested-Loop Join`。

这个 `SQL` 请求要全表扫描 `t2` 多达 `100` 次，总共扫描 `100*1000=10` 万行。

当然 `MySQL` 也没有使用这个 `Simple Nested-Loop Join` 算法，而是使用了另一个叫作 `Block Nested-Loop Join` 的算法，简称 `BNL`。

## Block Nested-Loop Join

这时候被驱动表上没有可用的索引，算法的流程是这样的：
- 把表 `t1` 的数据读入线程内存 `join_buffer` 中，由于语句中写的是 `select *` 因此是把整个表 `t1` 放入了内存。
- 扫描 `t2` 把 `t2` 中的每一行取出来跟 `join_buffer` 中的数据做对比，满足 `join` 条件的作为结果集的一部分返回。

这条 `SQL` 语句的 `explain` 结果如下：

    mysql> explain select * from t1 straight_join t2 on (t1.a=t2.b);
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
    |  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL |  100 |   100.00 | NULL                                               |
    |  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

在这个过程中，对表 `t1` 和 `t2` 都做了一次全表扫描，因此总的扫描行数是 `1100`。

由于 `join_buffer` 是以无序数组的方式组织的，因此对表 `t2` 中的每一行，都要做 `100` 次判断，总共需要在内存中做的判断次数是：`100*1000=10` 万次。

使用 `Block Nested-Loop Join` 算法进行的 `10` 万次判断是内存操作，速度上会快很多，性能也更好。

如果驱动表式一个`大表`，`join_buffer` 放不下怎么办呢？

`join_buffer` 的大小是由参数 `join_buffer_size` 设定的，默认值是 `256k`。

如果 `join_buffer_size` 放不下驱动表的所有数据，策略很简单，就是`分段`放。
- 首先获取第一批驱动表记录填满 `join_buffer`，然后扫描被驱动表记录逐一和 `join_buffer` 中的第一批驱动表记录做对比，满足 `join` 条件的作为结果集的一部分返回。
- 清空 `join_buffer` 继续获取下一批驱动表记录填满 `join_buffer`，然后再次扫描被驱动表记录逐一和 `join_buffer` 中的下一批驱动表记录做对比，满足 `join` 条件的作为结果集的一部分返回。
- 继续上面的步骤直到驱动表记录处理完成。

这个流程才体现出了这个算法名字中 `Block` 的由来，表示 `分块去 join`。

由于驱动表被分成了多次放入 `join_buffer` 中，导致被驱动表会被`扫描多次`。

所以当 `join_buffer` 大小确定的情况下，选择`小表`当驱动表，能减少`分段`数，进而能减少扫描被驱动表的次数。

同理 `join_buffer_size` 越大，一次可以放入的行越多，`分成`的段数也就越少，对被驱动表的扫描次数就越少。

所以如果 `join` 语句很慢，可以把 `join_buffer_size` 改大来改善查询性能。


理解了 `MySQL` 执行 `join` 的两种算法，再来回答开头的两个问题。

第一个问题：能不能使用 `join` 语句？
- 如果使用 `Index Nested-Loop Join` 算法，也就是说可以用上被驱动表上的索引，其实是没问题的。
- 如果使用 `Block Nested-Loop Join` 算法，扫描行数就会过多。尤其是在`大表`上的 `join` 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 `join` 尽量不要用。

所以在判断要不要使用 `join` 语句时就看 `explain` 结果里面 `Extra` 字段里面有没有出现`Block Nested Loop`字样。

第二个问题是：如果要使用 `join` 应该选择`大表`做驱动表还是选择`小表`做驱动表？
- 如果是 `Index Nested-Loop Join` 算法，应该选择`小表`做驱动表。
- 如果是 `Block Nested-Loop Join` 算法：
  - 在 `join_buffer_size` 足够大的时候是一样的。
  - 在 `join_buffer_size` 不够大的时候（这种情况更常见），应该选择`小表`做驱动表。

所以总是应该使用`小表做驱动表`。


这里需要说明一下什么叫作`小表`。

准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的过滤条件过滤完成之后，计算参与 `join` 的各个字段的总数据量，数据量小的那个表，就是`小表`，应该作为驱动表。

## 小结

今天介绍了 `MySQL` 执行 `join` 语句的两种可能算法，这两种算法是由能否使用被驱动表的索引决定的。

能否用上被驱动表的索引对 `join` 语句的性能影响很大。

通过对分析得出的结论：
- 如果可以使用被驱动表的索引 `join` 语句还是有其优势的。
- 不能使用被驱动表的索引，只能使用 `Block Nested-Loop Join` 算法，这样的语句就尽量不要使用。
- 使用 `join` 的时候应该让小表做驱动表。

# 完