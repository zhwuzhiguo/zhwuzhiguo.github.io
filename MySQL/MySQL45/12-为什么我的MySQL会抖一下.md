# 12-为什么我的MySQL会抖一下

## 你的 SQL 语句为什么变慢了

InnoDB 在处理更新语句的时候，只做了写`重做日志`这一个磁盘操作，就返回给客户端，本次更新成功。

当内存数据页跟磁盘数据页内容不一致的时候，称为`脏页`。  
内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为`干净页`。  
此时不论是`脏页`还是`干净页`，都在内存中。

平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔`抖`一下的那个瞬间，可能就是在`刷脏页`。

刷脏页的场景：
- 第一种场景：`InnoDB` 的 `redo log` 写满了。  
  这时候系统会停止所有更新操作，把 `checkpoint` 往前推进，`redo log` 留出空间可以继续写，这就需要将两个点之间的日志对应的所有`脏页`都刷到磁盘上。

- 第二种场景：系统内存不足。  
  当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是`脏页`，就要先将`脏页`写到磁盘。

- 第三种场景：系统`空闲`的时候。  
   `MySQL` 会见缝插针地找时间，只要有机会就刷一点`脏页`。

- 第四种场景：`MySQL` 正常关闭的情况。  
  这时候 `MySQL` 会把内存的脏页都刷新到磁盘上，下次 `MySQL` 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

**刷脏页的场景对性能的影响**

第三种场景是在 `MySQL` 空闲时的操作，这时系统没什么压力。

第四种场景是在 `MySQL` 关闭时的操作，也不用关心系统压力。

第一种场景是 `redo log` 写满了刷脏页，这种情况是 `InnoDB` 要尽量避免的。  
出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。

第二种场景是内存不够用了，要先将脏页写到磁盘，这种情况其实是`常态`。

`InnoDB` 用缓冲池管理内存，缓冲池中的内存页有三种状态：
- 第一种：还没有使用的。
- 第二种：使用了并且是`干净页`。
- 第三种：使用了并且是`脏页`。

`InnoDB` 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。

当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。  
这时候只能把最久不使用的数据页从内存中淘汰掉：
- 如果要淘汰的是`干净页`，就直接释放出来复用。
- 如果要淘汰的是`脏页`，就必须将`脏页`先刷到磁盘，变成`干净页`后才能复用。

所以`刷脏页`虽然是`常态`，但出现以下两种情况都会明显影响性能：
- 一个查询要淘汰的`脏页`个数太多，会导致查询的响应时间明显变长。
- `重做日志`写满，更新全部堵住，这种情况对敏感业务是不能接受的。

`InnoDB` 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。

## InnoDB 刷脏页的控制策略

首先要正确地告诉 `InnoDB` 所在主机的 `IO` 能力，这样 `InnoDB` 才能知道需要全力刷脏页的时候，可以刷多快。

参数 `innodb_io_capacity` 就是告诉 `InnoDB` 磁盘能力的，建议设置成磁盘的 `IOPS`。

磁盘的 `IOPS` 可以通过 `fio` 这个工具来测试。

下面的语句用来测试磁盘随机读写的命令：

    fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 

如果 `innodb_io_capacity` 参数设置太低，`InnoDB` 会认为系统的能力就这么差，所以刷脏页刷也就特别慢，这样就会造成脏页累积，影响查询和更新性能。

但也不能一直全力刷脏页，毕竟磁盘还需要服务其他请求。

接下来看看 `InnoDB` 怎么控制引擎按照`全力`的百分比来刷脏页。

如果刷太慢，首先是会内存`脏页`太多，其次是会 `redo log` 写满。

所以 `InnoDB` 的刷盘速度就要参考这两个因素：
- 一个是`脏页`比例。
- 一个是 `redo log` 写盘速度。

`InnoDB` 会根据这两个因素先单独算出两个数字：

- 第一个值：根据 `当前脏页比例` 占 `系统脏页比例上限` 的`占比`计算出一个 `0` 到 `100` 之间的数字。  
  参数 `innodb_max_dirty_pages_pct` 是脏页比例上限，默认值是 `75%`。

- 第二个值：根据当前写入 `redo log` 的序号和 `checkpoint` 对应的序号之间的差值计算出一个 `0` 到 `100` 之间的数字。

然后取两个值中`较大`的值记为 `R`，之后就按照 `innodb_io_capacity` 定义的能力乘以 `R%` 来控制刷脏页的速度。


`InnoDB` 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。

所以无论查询语句在需要内存的时候要求淘汰一个`脏页`，还是由于`刷脏页`的逻辑占用 `IO` 资源而影响更新语句，都可能是造成业务感知到的 MySQL `抖` 了一下的原因。

所以要尽量避免这种情况，要合理地设置 `innodb_io_capacity` 的值，并且平时要多关注`脏页`比例，不要让它经常接近脏页比例上限 `75%`。  


`MySQL` 中还有一个机制，准备刷一个`脏页`的时候，如果这个数据页旁边的数据页也是`脏页`，就会也一起刷掉，而且这个机制还可以`蔓延`，这样可能让查询更慢。

参数 `innodb_flush_neighbors` 用来控制这个行为：
- 值为 `1` 的时候会有上述的`连坐`机制。
- 值为 `0` 的时候只刷自己。

这个优化机制在机械硬盘时代是很有意义，可以减少很多随机 `IO`。

如果使用的是 `SSD` 这类 `IO` 性能比较高的设备，建议把 `innodb_flush_neighbors` 的值设置成 `0`，减少 `SQL` 语句响应时间。

## 小结

通过`重做日志`，数据库将随机写转换成了顺序写，大大提升了数据库的性能，但也由此也带来了内存`脏页`的问题。

`脏页`会被后台线程自动刷新到磁盘，也会由于数据页淘汰而触发`刷脏页`动作，而刷脏页的过程由于会占用资源，可能会让更新和查询语句的响应时间长一些。

# 完